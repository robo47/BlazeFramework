<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="PHPDoctor 2RC4 (http://peej.github.com/phpdoctor/)">
<meta name="when" content="Mon, 09 Aug 2010 18:21:11 +0000">

<link rel="stylesheet" type="text/css" href="../stylesheet.css">
<link rel="start" href="../overview-summary.html">

<title>blaze\io\File.php (Blaze Framework)</title>

</head>
<body id="file" onload="parent.document.title=document.title;">

<div class="header">
<h1>Blaze Framework</h1>
<ul>
<li><a href="../overview-summary.html">Overview</a></li>
<li>Package</li><li>Class</li><li>Tree</li><li><a href="../overview-files.html">Files</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
</ul>
</div>

<div class="small_links">
<a href="../index.html" target="_top">Frames</a>
<a href="../source\blaze\io\file.php.html" target="_top">No frames</a>
</div>
<hr>

<h1>blaze\io\File.php</h1>
<hr>

<a name="line1"></a><pre><?php
<a name="line2"></a>namespace blaze\io;
<a name="line3"></a>use blaze\lang\Object,
<a name="line4"></a>    blaze\lang\String,
<a name="line5"></a>    blaze\lang\NullPointerException,
<a name="line6"></a>    blaze\lang\StaticInitialization,
<a name="line7"></a>    blaze\lang\IllegalArgumentException,
<a name="line8"></a>    blaze\lang\Comparable,
<a name="line9"></a>    blaze\lang\ClassCastException;
<a name="line10"></a>/**
<a name="line11"></a> * Description of File
<a name="line12"></a> *
<a name="line13"></a> * @license http://www.opensource.org/licenses/gpl-3.0.html GPL
<a name="line14"></a> * @link    http://blazeframework.sourceforge.net
<a name="line15"></a> * @see     blaze\lang\ClassWrapper
<a name="line16"></a> * @since   1.0
<a name="line17"></a> * @version $Revision$
<a name="line18"></a> * @author  Christian Beikov
<a name="line19"></a> * @todo    Implementation and documentation.
<a name="line20"></a> */
<a name="line21"></a>class File extends Object implements StaticInitialization, Serializable, Comparable{
<a name="line22"></a>
<a name="line23"></a>    /**
<a name="line24"></a>     * The absolute path to the file which is represented by the object.
<a name="line25"></a>     * @var string The absolute path to the file.
<a name="line26"></a>     */
<a name="line27"></a>    private $path;
<a name="line28"></a>
<a name="line29"></a>    private static $fs;
<a name="line30"></a>    public static $pathSeparator;
<a name="line31"></a>    public static $directorySeparator;
<a name="line32"></a>
<a name="line33"></a>    public static function staticInit(){
<a name="line34"></a>        self::$fs = FileSystem::getInstance();
<a name="line35"></a>        self::$pathSeparator = self::$fs->getPathSeparator();
<a name="line36"></a>        self::$directorySeparator = self::$fs->getDirectorySeparator();
<a name="line37"></a>    }
<a name="line38"></a>
<a name="line39"></a>    /**
<a name="line40"></a>     * Description of the constructor of File
<a name="line41"></a>     * @param blaze\io\File|string|blaze\lang\String $parent The parent File-object or a string which represents a path
<a name="line42"></a>     * @param string|blaze\lang\String $child The child pathname
<a name="line43"></a>     */
<a name="line44"></a>    public function __construct($parent, $child = null){
<a name="line45"></a>        if($parent instanceof File){
<a name="line46"></a>            if($parent->path === '')
<a name="line47"></a>		$parent = self::$fs->getDefaultParent();
<a name="line48"></a>	    else
<a name="line49"></a>		$parent = $parent->path;
<a name="line50"></a>
<a name="line51"></a>            if($child === null){
<a name="line52"></a>		$this->path = self::$fs->normalize($parent);
<a name="line53"></a>	    } else {
<a name="line54"></a>		$this->path = self::$fs->resolve($parent,$child);
<a name="line55"></a>	    }
<a name="line56"></a>        }else if(is_string($parent) || $parent instanceof String){
<a name="line57"></a>            $parent = String::asNative($parent);
<a name="line58"></a>            
<a name="line59"></a>            if($child === null)
<a name="line60"></a>                $this->path = self::$fs->normalize($parent);
<a name="line61"></a>            else
<a name="line62"></a>                $this->path = self::$fs->resolve($parent,$child);
<a name="line63"></a>        }else{
<a name="line64"></a>            throw new IllegalArgumentException('The first parameter must be a File-object or a string');
<a name="line65"></a>        }
<a name="line66"></a>
<a name="line67"></a>        if($this->path !== null)
<a name="line68"></a>            $this->path = String::asWrapper($this->path);
<a name="line69"></a>    }
<a name="line70"></a>
<a name="line71"></a>        /* -- Path-component accessors -- */
<a name="line72"></a>
<a name="line73"></a>    /**
<a name="line74"></a>     * Returns the name of the file or directory denoted by this abstract
<a name="line75"></a>     * pathname.  This is just the last name in the pathname's name
<a name="line76"></a>     * sequence.  If the pathname's name sequence is empty, then the empty
<a name="line77"></a>     * string is returned.
<a name="line78"></a>     *
<a name="line79"></a>     * @return blaze\lang\String The name of the file or directory denoted by this abstract
<a name="line80"></a>     *          pathname, or the empty string if this pathname's name sequence
<a name="line81"></a>     *          is empty
<a name="line82"></a>     */
<a name="line83"></a>    public function getName() {
<a name="line84"></a>	$index = $this->path->lastIndexOf(self::$directorySeparator);
<a name="line85"></a>        return $this->path->substring($index + 1);
<a name="line86"></a>    }
<a name="line87"></a>
<a name="line88"></a>    /**
<a name="line89"></a>     * Returns the pathname string of this abstract pathname's parent, or
<a name="line90"></a>     * <code>null</code> if this pathname does not name a parent directory.
<a name="line91"></a>     *
<a name="line92"></a>     * <p> The <em>parent</em> of an abstract pathname consists of the
<a name="line93"></a>     * pathname's prefix, if any, and each name in the pathname's name
<a name="line94"></a>     * sequence except for the last.  If the name sequence is empty then
<a name="line95"></a>     * the pathname does not name a parent directory.
<a name="line96"></a>     *
<a name="line97"></a>     * @return blaze\lang\String The pathname string of the parent directory named by this
<a name="line98"></a>     *          abstract pathname, or <code>null</code> if this pathname
<a name="line99"></a>     *          does not name a parent
<a name="line100"></a>     */
<a name="line101"></a>    public function getParent() {
<a name="line102"></a>	$index = $this->path->lastIndexOf(self::$separatorChar);
<a name="line103"></a>	return $this->path->substring(0, $index);
<a name="line104"></a>    }
<a name="line105"></a>
<a name="line106"></a>    /**
<a name="line107"></a>     * Returns the abstract pathname of this abstract pathname's parent,
<a name="line108"></a>     * or <code>null</code> if this pathname does not name a parent
<a name="line109"></a>     * directory.
<a name="line110"></a>     *
<a name="line111"></a>     * <p> The <em>parent</em> of an abstract pathname consists of the
<a name="line112"></a>     * pathname's prefix, if any, and each name in the pathname's name
<a name="line113"></a>     * sequence except for the last.  If the name sequence is empty then
<a name="line114"></a>     * the pathname does not name a parent directory.
<a name="line115"></a>     *
<a name="line116"></a>     * @return blaze\io\File The abstract pathname of the parent directory named by this
<a name="line117"></a>     *          abstract pathname, or <code>null</code> if this pathname
<a name="line118"></a>     *          does not name a parent
<a name="line119"></a>     *
<a name="line120"></a>     * @since 1.2
<a name="line121"></a>     */
<a name="line122"></a>    public function getParentFile() {
<a name="line123"></a>	$p = $this->getParent();
<a name="line124"></a>	if ($p == null) return null;
<a name="line125"></a>	return new File($p);
<a name="line126"></a>    }
<a name="line127"></a>
<a name="line128"></a>    /**
<a name="line129"></a>     * Converts this abstract pathname into a pathname string.  The resulting
<a name="line130"></a>     * string uses the {@link #separator default name-separator character} to
<a name="line131"></a>     * separate the names in the name sequence.
<a name="line132"></a>     *
<a name="line133"></a>     * @return blaze\lang\String The string form of this abstract pathname
<a name="line134"></a>     */
<a name="line135"></a>    public function getPath() {
<a name="line136"></a>	return $this->path;
<a name="line137"></a>    }
<a name="line138"></a>
<a name="line139"></a>
<a name="line140"></a>    /* -- Path operations -- */
<a name="line141"></a>
<a name="line142"></a>    /**
<a name="line143"></a>     * Tests whether this abstract pathname is absolute.  The definition of
<a name="line144"></a>     * absolute pathname is system dependent.  On UNIX systems, a pathname is
<a name="line145"></a>     * absolute if its prefix is <code>"/"</code>.  On Microsoft Windows systems, a
<a name="line146"></a>     * pathname is absolute if its prefix is a drive specifier followed by
<a name="line147"></a>     * <code>"\\"</code>, or if its prefix is <code>"\\\\"</code>.
<a name="line148"></a>     *
<a name="line149"></a>     * @return boolean <code>true</code> if this abstract pathname is absolute,
<a name="line150"></a>     *          <code>false</code> otherwise
<a name="line151"></a>     */
<a name="line152"></a>    public function isAbsolute() {
<a name="line153"></a>	return self::$fs->isAbsolute($this);
<a name="line154"></a>    }
<a name="line155"></a>
<a name="line156"></a>    /**
<a name="line157"></a>     *
<a name="line158"></a>     * @param blaze\io\File|blaze\lang\String|string $file The File-Object or path of the child.
<a name="line159"></a>     * @param boolean $direct
<a name="line160"></a>     * @return boolean
<a name="line161"></a>     */
<a name="line162"></a>    public function isChildOf($file, $direct = false){
<a name="line163"></a>        if(!$file instanceof File)
<a name="line164"></a>            $file = new File(String::asNative($file));
<a name="line165"></a>
<a name="line166"></a>        $parentPath = $file->getAbsolutePath();
<a name="line167"></a>        $childPath = $this->getAbsolutePath();
<a name="line168"></a>
<a name="line169"></a>        $index = $childPath->indexOf($parentPath);
<a name="line170"></a>        if($index === -1)
<a name="line171"></a>            return false;
<a name="line172"></a>        if(!$direct)
<a name="line173"></a>            return $index === 0;
<a name="line174"></a>        return $childPath->substring($parentPath->length())->indexOf(DIRECTORY_SEPARATOR) < 0;
<a name="line175"></a>    }
<a name="line176"></a>
<a name="line177"></a>    /**
<a name="line178"></a>     *
<a name="line179"></a>     * @param blaze\io\File|blaze\lang\String|string $file The File-Object or path of the parent.
<a name="line180"></a>     * @param boolean $direct
<a name="line181"></a>     * @return boolean
<a name="line182"></a>     */
<a name="line183"></a>    public function isParentOf($file, $direct = false){
<a name="line184"></a>        $f = new File($file);
<a name="line185"></a>        return $f->isChildOf($this,$direct);
<a name="line186"></a>    }
<a name="line187"></a>
<a name="line188"></a>    /**
<a name="line189"></a>     * Returns the absolute pathname string of this abstract pathname.
<a name="line190"></a>     *
<a name="line191"></a>     * <p> If this abstract pathname is already absolute, then the pathname
<a name="line192"></a>     * string is simply returned as if by the <code>{@link #getPath}</code>
<a name="line193"></a>     * method.  If this abstract pathname is the empty abstract pathname then
<a name="line194"></a>     * the pathname string of the current user directory, which is named by the
<a name="line195"></a>     * system property <code>user.dir</code>, is returned.  Otherwise this
<a name="line196"></a>     * pathname is resolved in a system-dependent way.  On UNIX systems, a
<a name="line197"></a>     * relative pathname is made absolute by resolving it against the current
<a name="line198"></a>     * user directory.  On Microsoft Windows systems, a relative pathname is made absolute
<a name="line199"></a>     * by resolving it against the current directory of the drive named by the
<a name="line200"></a>     * pathname, if any; if not, it is resolved against the current user
<a name="line201"></a>     * directory.
<a name="line202"></a>     *
<a name="line203"></a>     * @return blaze\lang\String The absolute pathname string denoting the same file or
<a name="line204"></a>     *          directory as this abstract pathname
<a name="line205"></a>     *
<a name="line206"></a>     * @throws  SecurityException
<a name="line207"></a>     *          If a required system property value cannot be accessed.
<a name="line208"></a>     *
<a name="line209"></a>     * @see     java.io.File#isAbsolute()
<a name="line210"></a>     */
<a name="line211"></a>    public function getAbsolutePath() {
<a name="line212"></a>	return new String(self::$fs->resolve($this->path));
<a name="line213"></a>    }
<a name="line214"></a>
<a name="line215"></a>    /**
<a name="line216"></a>     * Returns the absolute form of this abstract pathname.  Equivalent to
<a name="line217"></a>     * <code>new&nbsp;File(this.{@link #getAbsolutePath})</code>.
<a name="line218"></a>     *
<a name="line219"></a>     * @return blaze\io\File The absolute abstract pathname denoting the same file or
<a name="line220"></a>     *          directory as this abstract pathname
<a name="line221"></a>     *
<a name="line222"></a>     * @throws  SecurityException
<a name="line223"></a>     *          If a required system property value cannot be accessed.
<a name="line224"></a>     *
<a name="line225"></a>     * @since 1.2
<a name="line226"></a>     */
<a name="line227"></a>    public function getAbsoluteFile() {
<a name="line228"></a>        $absPath = $this->getAbsolutePath();
<a name="line229"></a>	return new File($absPath);
<a name="line230"></a>    }
<a name="line231"></a>
<a name="line232"></a>    /**
<a name="line233"></a>     * Returns the canonical pathname string of this abstract pathname.
<a name="line234"></a>     *
<a name="line235"></a>     * <p> A canonical pathname is both absolute and unique.  The precise
<a name="line236"></a>     * definition of canonical form is system-dependent.  This method first
<a name="line237"></a>     * converts this pathname to absolute form if necessary, as if by invoking the
<a name="line238"></a>     * {@link #getAbsolutePath} method, and then maps it to its unique form in a
<a name="line239"></a>     * system-dependent way.  This typically involves removing redundant names
<a name="line240"></a>     * such as <tt>"."</tt> and <tt>".."</tt> from the pathname, resolving
<a name="line241"></a>     * symbolic links (on UNIX platforms), and converting drive letters to a
<a name="line242"></a>     * standard case (on Microsoft Windows platforms).
<a name="line243"></a>     *
<a name="line244"></a>     * <p> Every pathname that denotes an existing file or directory has a
<a name="line245"></a>     * unique canonical form.  Every pathname that denotes a nonexistent file
<a name="line246"></a>     * or directory also has a unique canonical form.  The canonical form of
<a name="line247"></a>     * the pathname of a nonexistent file or directory may be different from
<a name="line248"></a>     * the canonical form of the same pathname after the file or directory is
<a name="line249"></a>     * created.  Similarly, the canonical form of the pathname of an existing
<a name="line250"></a>     * file or directory may be different from the canonical form of the same
<a name="line251"></a>     * pathname after the file or directory is deleted.
<a name="line252"></a>     *
<a name="line253"></a>     * @return blaze\lang\String The canonical pathname string denoting the same file or
<a name="line254"></a>     *          directory as this abstract pathname
<a name="line255"></a>     *
<a name="line256"></a>     * @throws  IOException
<a name="line257"></a>     *          If an I/O error occurs, which is possible because the
<a name="line258"></a>     *          construction of the canonical pathname may require
<a name="line259"></a>     *          filesystem queries
<a name="line260"></a>     *
<a name="line261"></a>     * @throws  SecurityException
<a name="line262"></a>     *          If a required system property value cannot be accessed, or
<a name="line263"></a>     *          if a security manager exists and its <code>{@link
<a name="line264"></a>     *          java.lang.SecurityManager#checkRead}</code> method denies
<a name="line265"></a>     *          read access to the file
<a name="line266"></a>     *
<a name="line267"></a>     * @since   JDK1.1
<a name="line268"></a>     */
<a name="line269"></a>    public function getCanonicalPath(){
<a name="line270"></a>	return new String(self::$fs->canonicalize(self::$fs->resolve($this)));
<a name="line271"></a>    }
<a name="line272"></a>
<a name="line273"></a>    /**
<a name="line274"></a>     * Returns the canonical form of this abstract pathname.  Equivalent to
<a name="line275"></a>     * <code>new&nbsp;File(this.{@link #getCanonicalPath})</code>.
<a name="line276"></a>     *
<a name="line277"></a>     * @return blaze\io\File The canonical pathname string denoting the same file or
<a name="line278"></a>     *          directory as this abstract pathname
<a name="line279"></a>     *
<a name="line280"></a>     * @throws  IOException
<a name="line281"></a>     *          If an I/O error occurs, which is possible because the
<a name="line282"></a>     *          construction of the canonical pathname may require
<a name="line283"></a>     *          filesystem queries
<a name="line284"></a>     *
<a name="line285"></a>     * @throws  SecurityException
<a name="line286"></a>     *          If a required system property value cannot be accessed, or
<a name="line287"></a>     *          if a security manager exists and its <code>{@link
<a name="line288"></a>     *          java.lang.SecurityManager#checkRead}</code> method denies
<a name="line289"></a>     *          read access to the file
<a name="line290"></a>     *
<a name="line291"></a>     * @since 1.2
<a name="line292"></a>     */
<a name="line293"></a>    public function getCanonicalFile(){
<a name="line294"></a>        $canonPath = $this->getCanonicalPath();
<a name="line295"></a>	return new File($canonPath);
<a name="line296"></a>    }
<a name="line297"></a>
<a name="line298"></a>//    private static function slashify(String path, boolean isDirectory) {
<a name="line299"></a>//	String p = path;
<a name="line300"></a>//	if (File.separatorChar != '/')
<a name="line301"></a>//	    p = p.replace(File.separatorChar, '/');
<a name="line302"></a>//	if (!p.startsWith("/"))
<a name="line303"></a>//	    p = "/" + p;
<a name="line304"></a>//	if (!p.endsWith("/") && isDirectory)
<a name="line305"></a>//	    p = p + "/";
<a name="line306"></a>//	return p;
<a name="line307"></a>//    }
<a name="line308"></a>
<a name="line309"></a>    /**
<a name="line310"></a>     * Converts this abstract pathname into a <code>file:</code> URL.  The
<a name="line311"></a>     * exact form of the URL is system-dependent.  If it can be determined that
<a name="line312"></a>     * the file denoted by this abstract pathname is a directory, then the
<a name="line313"></a>     * resulting URL will end with a slash.
<a name="line314"></a>     *
<a name="line315"></a>     * @return  A URL object representing the equivalent file URL
<a name="line316"></a>     *
<a name="line317"></a>     * @throws  MalformedURLException
<a name="line318"></a>     *          If the path cannot be parsed as a URL
<a name="line319"></a>     *
<a name="line320"></a>     * @see     #toURI()
<a name="line321"></a>     * @see     java.net.URI
<a name="line322"></a>     * @see     java.net.URI#toURL()
<a name="line323"></a>     * @see     java.net.URL
<a name="line324"></a>     * @since   1.2
<a name="line325"></a>     *
<a name="line326"></a>     * @deprecated This method does not automatically escape characters that
<a name="line327"></a>     * are illegal in URLs.  It is recommended that new code convert an
<a name="line328"></a>     * abstract pathname into a URL by first converting it into a URI, via the
<a name="line329"></a>     * {@link #toURI() toURI} method, and then converting the URI into a URL
<a name="line330"></a>     * via the {@link java.net.URI#toURL() URI.toURL} method.
<a name="line331"></a>     */
<a name="line332"></a>//    public URL toURL() throws MalformedURLException {
<a name="line333"></a>//	return new URL("file", "", slashify(getAbsolutePath(), isDirectory()));
<a name="line334"></a>//    }
<a name="line335"></a>
<a name="line336"></a>    /**
<a name="line337"></a>     * Constructs a <tt>file:</tt> URI that represents this abstract pathname.
<a name="line338"></a>     *
<a name="line339"></a>     * <p> The exact form of the URI is system-dependent.  If it can be
<a name="line340"></a>     * determined that the file denoted by this abstract pathname is a
<a name="line341"></a>     * directory, then the resulting URI will end with a slash.
<a name="line342"></a>     *
<a name="line343"></a>     * <p> For a given abstract pathname <i>f</i>, it is guaranteed that
<a name="line344"></a>     *
<a name="line345"></a>     * <blockquote><tt>
<a name="line346"></a>     * new {@link #File(java.net.URI) File}(</tt><i>&nbsp;f</i><tt>.toURI()).equals(</tt><i>&nbsp;f</i><tt>.{@link #getAbsoluteFile() getAbsoluteFile}())
<a name="line347"></a>     * </tt></blockquote>
<a name="line348"></a>     *
<a name="line349"></a>     * so long as the original abstract pathname, the URI, and the new abstract
<a name="line350"></a>     * pathname are all created in (possibly different invocations of) the same
<a name="line351"></a>     * Java virtual machine.  Due to the system-dependent nature of abstract
<a name="line352"></a>     * pathnames, however, this relationship typically does not hold when a
<a name="line353"></a>     * <tt>file:</tt> URI that is created in a virtual machine on one operating
<a name="line354"></a>     * system is converted into an abstract pathname in a virtual machine on a
<a name="line355"></a>     * different operating system.
<a name="line356"></a>     *
<a name="line357"></a>     * @return URI An absolute, hierarchical URI with a scheme equal to
<a name="line358"></a>     *          <tt>"file"</tt>, a path representing this abstract pathname,
<a name="line359"></a>     *          and undefined authority, query, and fragment components
<a name="line360"></a>     * @throws SecurityException If a required system property value cannot
<a name="line361"></a>     * be accessed.
<a name="line362"></a>     *
<a name="line363"></a>     * @see #File(java.net.URI)
<a name="line364"></a>     * @see java.net.URI
<a name="line365"></a>     * @see java.net.URI#toURL()
<a name="line366"></a>     * @since 1.4
<a name="line367"></a>     */
<a name="line368"></a>    public function toURI() {
<a name="line369"></a>	try {
<a name="line370"></a>	    $f = $this->getAbsoluteFile();
<a name="line371"></a>	    $sp = $this->slashify($f->getPath(), $f->isDirectory());
<a name="line372"></a>	    if ($sp->startsWith("//"))
<a name="line373"></a>		$sp = "//" + $sp;
<a name="line374"></a>	    return new URI("file", null, $sp, null);
<a name="line375"></a>	} catch (URISyntaxException $x) {
<a name="line376"></a>	    throw new Error($x);		// Can't happen
<a name="line377"></a>	}
<a name="line378"></a>    }
<a name="line379"></a>
<a name="line380"></a>
<a name="line381"></a>    /* -- Attribute accessors -- */
<a name="line382"></a>
<a name="line383"></a>    /**
<a name="line384"></a>     * Tests whether the application can read the file denoted by this
<a name="line385"></a>     * abstract pathname.
<a name="line386"></a>     *
<a name="line387"></a>     * @return boolean <code>true</code> if and only if the file specified by this
<a name="line388"></a>     *          abstract pathname exists <em>and</em> can be read by the
<a name="line389"></a>     *          application; <code>false</code> otherwise
<a name="line390"></a>     *
<a name="line391"></a>     * @throws  SecurityException
<a name="line392"></a>     *          If a security manager exists and its <code>{@link
<a name="line393"></a>     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>
<a name="line394"></a>     *          method denies read access to the file
<a name="line395"></a>     */
<a name="line396"></a>    public function canRead() {
<a name="line397"></a>	return self::$fs->checkAccess($this, FileSystem::ACCESS_READ);
<a name="line398"></a>    }
<a name="line399"></a>
<a name="line400"></a>    /**
<a name="line401"></a>     * Tests whether the application can modify the file denoted by this
<a name="line402"></a>     * abstract pathname.
<a name="line403"></a>     *
<a name="line404"></a>     * @return boolean <code>true</code> if and only if the file system actually
<a name="line405"></a>     *          contains a file denoted by this abstract pathname <em>and</em>
<a name="line406"></a>     *          the application is allowed to write to the file;
<a name="line407"></a>     *          <code>false</code> otherwise.
<a name="line408"></a>     *
<a name="line409"></a>     * @throws  SecurityException
<a name="line410"></a>     *          If a security manager exists and its <code>{@link
<a name="line411"></a>     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
<a name="line412"></a>     *          method denies write access to the file
<a name="line413"></a>     */
<a name="line414"></a>    public function canWrite() {
<a name="line415"></a>	return self::$fs->checkAccess($this, FileSystem::ACCESS_WRITE);
<a name="line416"></a>    }
<a name="line417"></a>
<a name="line418"></a>    /**
<a name="line419"></a>     * Tests whether the file or directory denoted by this abstract pathname
<a name="line420"></a>     * exists.
<a name="line421"></a>     *
<a name="line422"></a>     * @return boolean <code>true</code> if and only if the file or directory denoted
<a name="line423"></a>     *          by this abstract pathname exists; <code>false</code> otherwise
<a name="line424"></a>     *
<a name="line425"></a>     * @throws  SecurityException
<a name="line426"></a>     *          If a security manager exists and its <code>{@link
<a name="line427"></a>     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>
<a name="line428"></a>     *          method denies read access to the file or directory
<a name="line429"></a>     */
<a name="line430"></a>    public function exists() {
<a name="line431"></a>	return self::$fs->fileExists($this);
<a name="line432"></a>    }
<a name="line433"></a>
<a name="line434"></a>    /**
<a name="line435"></a>     * Tests whether the file denoted by this abstract pathname is a
<a name="line436"></a>     * directory.
<a name="line437"></a>     *
<a name="line438"></a>     * @return boolean <code>true</code> if and only if the file denoted by this
<a name="line439"></a>     *          abstract pathname exists <em>and</em> is a directory;
<a name="line440"></a>     *          <code>false</code> otherwise
<a name="line441"></a>     *
<a name="line442"></a>     * @throws  SecurityException
<a name="line443"></a>     *          If a security manager exists and its <code>{@link
<a name="line444"></a>     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>
<a name="line445"></a>     *          method denies read access to the file
<a name="line446"></a>     */
<a name="line447"></a>    public function isDirectory() {
<a name="line448"></a>	return self::$fs->isDirectory($this);
<a name="line449"></a>    }
<a name="line450"></a>
<a name="line451"></a>    /**
<a name="line452"></a>     * Tests whether the file denoted by this abstract pathname is a normal
<a name="line453"></a>     * file.  A file is <em>normal</em> if it is not a directory and, in
<a name="line454"></a>     * addition, satisfies other system-dependent criteria.  Any non-directory
<a name="line455"></a>     * file created by a Java application is guaranteed to be a normal file.
<a name="line456"></a>     *
<a name="line457"></a>     * @return boolean <code>true</code> if and only if the file denoted by this
<a name="line458"></a>     *          abstract pathname exists <em>and</em> is a normal file;
<a name="line459"></a>     *          <code>false</code> otherwise
<a name="line460"></a>     *
<a name="line461"></a>     * @throws  SecurityException
<a name="line462"></a>     *          If a security manager exists and its <code>{@link
<a name="line463"></a>     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>
<a name="line464"></a>     *          method denies read access to the file
<a name="line465"></a>     */
<a name="line466"></a>    public function isFile() {
<a name="line467"></a>	return self::$fs->isFile($this);
<a name="line468"></a>    }
<a name="line469"></a>
<a name="line470"></a>    /**
<a name="line471"></a>     * Tests whether the file named by this abstract pathname is a hidden
<a name="line472"></a>     * file.  The exact definition of <em>hidden</em> is system-dependent.  On
<a name="line473"></a>     * UNIX systems, a file is considered to be hidden if its name begins with
<a name="line474"></a>     * a period character (<code>'.'</code>).  On Microsoft Windows systems, a file is
<a name="line475"></a>     * considered to be hidden if it has been marked as such in the filesystem.
<a name="line476"></a>     *
<a name="line477"></a>     * @return  <code>true</code> if and only if the file denoted by this
<a name="line478"></a>     *          abstract pathname is hidden according to the conventions of the
<a name="line479"></a>     *          underlying platform
<a name="line480"></a>     *
<a name="line481"></a>     * @throws  SecurityException
<a name="line482"></a>     *          If a security manager exists and its <code>{@link
<a name="line483"></a>     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>
<a name="line484"></a>     *          method denies read access to the file
<a name="line485"></a>     *
<a name="line486"></a>     * @since 1.2
<a name="line487"></a>     */
<a name="line488"></a>    public function isHidden() {
<a name="line489"></a>	return false;//((fs.getBooleanAttributes(this) & FileSystem.BA_HIDDEN) != 0);
<a name="line490"></a>    }
<a name="line491"></a>
<a name="line492"></a>    /**
<a name="line493"></a>     * Returns the time that the file denoted by this abstract pathname was
<a name="line494"></a>     * last modified.
<a name="line495"></a>     *
<a name="line496"></a>     * @return long A <code>long</code> value representing the time the file was
<a name="line497"></a>     *          last modified, measured in milliseconds since the epoch
<a name="line498"></a>     *          (00:00:00 GMT, January 1, 1970), or <code>0L</code> if the
<a name="line499"></a>     *          file does not exist or if an I/O error occurs
<a name="line500"></a>     *
<a name="line501"></a>     * @throws  SecurityException
<a name="line502"></a>     *          If a security manager exists and its <code>{@link
<a name="line503"></a>     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>
<a name="line504"></a>     *          method denies read access to the file
<a name="line505"></a>     */
<a name="line506"></a>    public function lastModified() {
<a name="line507"></a>	return self::$fs->getLastModifiedTime($this);
<a name="line508"></a>    }
<a name="line509"></a>
<a name="line510"></a>    /**
<a name="line511"></a>     * Returns the length of the file denoted by this abstract pathname.
<a name="line512"></a>     * The return value is unspecified if this pathname denotes a directory.
<a name="line513"></a>     *
<a name="line514"></a>     * @return long The length, in bytes, of the file denoted by this abstract
<a name="line515"></a>     *          pathname, or <code>0L</code> if the file does not exist.  Some
<a name="line516"></a>     *          operating systems may return <code>0L</code> for pathnames
<a name="line517"></a>     *          denoting system-dependent entities such as devices or pipes.
<a name="line518"></a>     *
<a name="line519"></a>     * @throws  SecurityException
<a name="line520"></a>     *          If a security manager exists and its <code>{@link
<a name="line521"></a>     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>
<a name="line522"></a>     *          method denies read access to the file
<a name="line523"></a>     */
<a name="line524"></a>    public function length() {
<a name="line525"></a>	return self::$fs->getLength($this);
<a name="line526"></a>    }
<a name="line527"></a>
<a name="line528"></a>
<a name="line529"></a>    /* -- File operations -- */
<a name="line530"></a>
<a name="line531"></a>    /**
<a name="line532"></a>     * Atomically creates a new, empty file named by this abstract pathname if
<a name="line533"></a>     * and only if a file with this name does not yet exist.  The check for the
<a name="line534"></a>     * existence of the file and the creation of the file if it does not exist
<a name="line535"></a>     * are a single operation that is atomic with respect to all other
<a name="line536"></a>     * filesystem activities that might affect the file.
<a name="line537"></a>     * <P>
<a name="line538"></a>     * Note: this method should <i>not</i> be used for file-locking, as
<a name="line539"></a>     * the resulting protocol cannot be made to work reliably. The
<a name="line540"></a>     * {@link java.nio.channels.FileLock FileLock}
<a name="line541"></a>     * facility should be used instead.
<a name="line542"></a>     *
<a name="line543"></a>     * @return boolean <code>true</code> if the named file does not exist and was
<a name="line544"></a>     *          successfully created; <code>false</code> if the named file
<a name="line545"></a>     *          already exists
<a name="line546"></a>     *
<a name="line547"></a>     * @throws  IOException
<a name="line548"></a>     *          If an I/O error occurred
<a name="line549"></a>     *
<a name="line550"></a>     * @throws  SecurityException
<a name="line551"></a>     *          If a security manager exists and its <code>{@link
<a name="line552"></a>     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
<a name="line553"></a>     *          method denies write access to the file
<a name="line554"></a>     *
<a name="line555"></a>     * @since 1.2
<a name="line556"></a>     */
<a name="line557"></a>    public function createNewFile() {
<a name="line558"></a>	return self::$fs->createFileExclusively($this->path);
<a name="line559"></a>    }
<a name="line560"></a>
<a name="line561"></a>    /**
<a name="line562"></a>     * Deletes the file or directory denoted by this abstract pathname.  If
<a name="line563"></a>     * this pathname denotes a directory, then the directory must be empty in
<a name="line564"></a>     * order to be deleted.
<a name="line565"></a>     *
<a name="line566"></a>     * @return boolean <code>true</code> if and only if the file or directory is
<a name="line567"></a>     *          successfully deleted; <code>false</code> otherwise
<a name="line568"></a>     *
<a name="line569"></a>     * @throws  SecurityException
<a name="line570"></a>     *          If a security manager exists and its <code>{@link
<a name="line571"></a>     *          java.lang.SecurityManager#checkDelete}</code> method denies
<a name="line572"></a>     *          delete access to the file
<a name="line573"></a>     */
<a name="line574"></a>    public function delete() {
<a name="line575"></a>	return self::$fs->delete($this);
<a name="line576"></a>    }
<a name="line577"></a>
<a name="line578"></a>    /**
<a name="line579"></a>     * Requests that the file or directory denoted by this abstract
<a name="line580"></a>     * pathname be deleted when the virtual machine terminates.
<a name="line581"></a>     * Files (or directories) are deleted in the reverse order that
<a name="line582"></a>     * they are registered. Invoking this method to delete a file or
<a name="line583"></a>     * directory that is already registered for deletion has no effect.
<a name="line584"></a>     * Deletion will be attempted only for normal termination of the
<a name="line585"></a>     * virtual machine, as defined by the Java Language Specification.
<a name="line586"></a>     *
<a name="line587"></a>     * <p> Once deletion has been requested, it is not possible to cancel the
<a name="line588"></a>     * request.  This method should therefore be used with care.
<a name="line589"></a>     *
<a name="line590"></a>     * <P>
<a name="line591"></a>     * Note: this method should <i>not</i> be used for file-locking, as
<a name="line592"></a>     * the resulting protocol cannot be made to work reliably. The
<a name="line593"></a>     * {@link java.nio.channels.FileLock FileLock}
<a name="line594"></a>     * facility should be used instead.
<a name="line595"></a>     *
<a name="line596"></a>     * @throws  SecurityException
<a name="line597"></a>     *          If a security manager exists and its <code>{@link
<a name="line598"></a>     *          java.lang.SecurityManager#checkDelete}</code> method denies
<a name="line599"></a>     *          delete access to the file
<a name="line600"></a>     *
<a name="line601"></a>     * @see #delete
<a name="line602"></a>     *
<a name="line603"></a>     * @since 1.2
<a name="line604"></a>     * @todo Class DeleteOnExitHook must be implemented
<a name="line605"></a>     */
<a name="line606"></a>    public function deleteOnExit() {
<a name="line607"></a>	DeleteOnExitHook::add($path);
<a name="line608"></a>    }
<a name="line609"></a>
<a name="line610"></a>    /**
<a name="line611"></a>     * Returns an array of strings naming the files and directories in the
<a name="line612"></a>     * directory denoted by this abstract pathname that satisfy the specified
<a name="line613"></a>     * filter.  The behavior of this method is the same as that of the
<a name="line614"></a>     * <code>{@link #list()}</code> method, except that the strings in the
<a name="line615"></a>     * returned array must satisfy the filter.  If the given
<a name="line616"></a>     * <code>filter</code> is <code>null</code> then all names are accepted.
<a name="line617"></a>     * Otherwise, a name satisfies the filter if and only if the value
<a name="line618"></a>     * <code>true</code> results when the <code>{@link
<a name="line619"></a>     * FilenameFilter#accept}</code> method of the filter is invoked on this
<a name="line620"></a>     * abstract pathname and the name of a file or directory in the directory
<a name="line621"></a>     * that it denotes.
<a name="line622"></a>     *
<a name="line623"></a>     * @param  filter  A filename filter
<a name="line624"></a>     *
<a name="line625"></a>     * @return array[blaze\lang\String] An array of strings naming the files and directories in the
<a name="line626"></a>     *          directory denoted by this abstract pathname that were accepted
<a name="line627"></a>     *          by the given <code>filter</code>.  The array will be empty if
<a name="line628"></a>     *          the directory is empty or if no names were accepted by the
<a name="line629"></a>     *          filter.  Returns <code>null</code> if this abstract pathname
<a name="line630"></a>     *          does not denote a directory, or if an I/O error occurs.
<a name="line631"></a>     *
<a name="line632"></a>     * @throws  SecurityException
<a name="line633"></a>     *          If a security manager exists and its <code>{@link
<a name="line634"></a>     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>
<a name="line635"></a>     *          method denies read access to the directory
<a name="line636"></a>     */
<a name="line637"></a>    public function listFilenames(FilenameFilter $filter = null) {
<a name="line638"></a>//	String names[] = list();
<a name="line639"></a>//	if ((names == null) || (filter == null)) {
<a name="line640"></a>//	    return names;
<a name="line641"></a>//	}
<a name="line642"></a>//	ArrayList v = new ArrayList();
<a name="line643"></a>//	for (int i = 0 ; i < names.length ; i++) {
<a name="line644"></a>//	    if (filter.accept(this, names[i])) {
<a name="line645"></a>//		v.add(names[i]);
<a name="line646"></a>//	    }
<a name="line647"></a>//	}
<a name="line648"></a>//	return (String[])(v.toArray(new String[v.size()]));
<a name="line649"></a>//
<a name="line650"></a>//      return self::$fs->listFiles($this);
<a name="line651"></a>    }
<a name="line652"></a>
<a name="line653"></a>    /**
<a name="line654"></a>     * Returns an array of abstract pathnames denoting the files and
<a name="line655"></a>     * directories in the directory denoted by this abstract pathname that
<a name="line656"></a>     * satisfy the specified filter.  The behavior of this method is the
<a name="line657"></a>     * same as that of the <code>{@link #listFiles()}</code> method, except
<a name="line658"></a>     * that the pathnames in the returned array must satisfy the filter.
<a name="line659"></a>     * If the given <code>filter</code> is <code>null</code> then all
<a name="line660"></a>     * pathnames are accepted.  Otherwise, a pathname satisfies the filter
<a name="line661"></a>     * if and only if the value <code>true</code> results when the
<a name="line662"></a>     * <code>{@link FileFilter#accept(java.io.File)}</code> method of
<a name="line663"></a>     * the filter is invoked on the pathname.
<a name="line664"></a>     *
<a name="line665"></a>     * @param  filter  A file filter
<a name="line666"></a>     *
<a name="line667"></a>     * @return array[blaze\lang\File] An array of abstract pathnames denoting the files and
<a name="line668"></a>     *          directories in the directory denoted by this abstract
<a name="line669"></a>     *          pathname.  The array will be empty if the directory is
<a name="line670"></a>     *          empty.  Returns <code>null</code> if this abstract pathname
<a name="line671"></a>     *          does not denote a directory, or if an I/O error occurs.
<a name="line672"></a>     *
<a name="line673"></a>     * @throws  SecurityException
<a name="line674"></a>     *          If a security manager exists and its <code>{@link
<a name="line675"></a>     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>
<a name="line676"></a>     *          method denies read access to the directory
<a name="line677"></a>     *
<a name="line678"></a>     * @since 1.2
<a name="line679"></a>     */
<a name="line680"></a>    public function listFiles(FileFilter $filter = null) {
<a name="line681"></a>        /**
<a name="line682"></a>         * @var array[string]
<a name="line683"></a>         */
<a name="line684"></a>
<a name="line685"></a>
<a name="line686"></a>	return self::$fs->listFiles($this);
<a name="line687"></a>//	$ss = self::$fs->listFiles($this);
<a name="line688"></a>
<a name="line689"></a>//        if ($ss == null) return null;
<a name="line690"></a>//        $v = new ArrayList();
<a name="line691"></a>//        for ($i = 0 ; $i < $ss->length ; $i++) {
<a name="line692"></a>//            $f = new File($ss[$i], $this);
<a name="line693"></a>//            if (($filter == null) || $filter->accept($f)) {
<a name="line694"></a>//                $v->add($f);
<a name="line695"></a>//            }
<a name="line696"></a>//        }
<a name="line697"></a>//        return $v->toArray();
<a name="line698"></a>    }
<a name="line699"></a>
<a name="line700"></a>    /**
<a name="line701"></a>     * Creates the directory named by this abstract pathname.
<a name="line702"></a>     *
<a name="line703"></a>     * @return boolean <code>true</code> if and only if the directory was
<a name="line704"></a>     *          created; <code>false</code> otherwise
<a name="line705"></a>     *
<a name="line706"></a>     * @throws  SecurityException
<a name="line707"></a>     *          If a security manager exists and its <code>{@link
<a name="line708"></a>     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
<a name="line709"></a>     *          method does not permit the named directory to be created
<a name="line710"></a>     */
<a name="line711"></a>    public function mkdir() {
<a name="line712"></a>	return self::$fs->createDirectory($this);
<a name="line713"></a>    }
<a name="line714"></a>
<a name="line715"></a>    /**
<a name="line716"></a>     * Creates the directory named by this abstract pathname, including any
<a name="line717"></a>     * necessary but nonexistent parent directories.  Note that if this
<a name="line718"></a>     * operation fails it may have succeeded in creating some of the necessary
<a name="line719"></a>     * parent directories.
<a name="line720"></a>     *
<a name="line721"></a>     * @return boolean <code>true</code> if and only if the directory was created,
<a name="line722"></a>     *          along with all necessary parent directories; <code>false</code>
<a name="line723"></a>     *          otherwise
<a name="line724"></a>     *
<a name="line725"></a>     * @throws  SecurityException
<a name="line726"></a>     *          If a security manager exists and its <code>{@link
<a name="line727"></a>     *          java.lang.SecurityManager#checkRead(java.lang.String)}</code>
<a name="line728"></a>     *          method does not permit verification of the existence of the
<a name="line729"></a>     *          named directory and all necessary parent directories; or if
<a name="line730"></a>     *          the <code>{@link
<a name="line731"></a>     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
<a name="line732"></a>     *          method does not permit the named directory and all necessary
<a name="line733"></a>     *          parent directories to be created
<a name="line734"></a>     */
<a name="line735"></a>    public function mkdirs() {
<a name="line736"></a>	if ($this->exists()) {
<a name="line737"></a>	    return false;
<a name="line738"></a>	}
<a name="line739"></a>	if ($this->mkdir()) {
<a name="line740"></a> 	    return true;
<a name="line741"></a> 	}
<a name="line742"></a>        $canonFile = null;
<a name="line743"></a>        try {
<a name="line744"></a>            $canonFile = $this->getCanonicalFile();
<a name="line745"></a>        } catch (IOException $e) {
<a name="line746"></a>            return false;
<a name="line747"></a>        }
<a name="line748"></a>
<a name="line749"></a>	$parent = $canonFile->getParentFile();
<a name="line750"></a>	return ($parent != null && ($parent->mkdirs() || $parent->exists()) &&
<a name="line751"></a>		$canonFile->mkdir());
<a name="line752"></a>    }
<a name="line753"></a>
<a name="line754"></a>    /**
<a name="line755"></a>     * Renames the file denoted by this abstract pathname.
<a name="line756"></a>     *
<a name="line757"></a>     * <p> Many aspects of the behavior of this method are inherently
<a name="line758"></a>     * platform-dependent: The rename operation might not be able to move a
<a name="line759"></a>     * file from one filesystem to another, it might not be atomic, and it
<a name="line760"></a>     * might not succeed if a file with the destination abstract pathname
<a name="line761"></a>     * already exists.  The return value should always be checked to make sure
<a name="line762"></a>     * that the rename operation was successful.
<a name="line763"></a>     *
<a name="line764"></a>     * @param  dest  The new abstract pathname for the named file
<a name="line765"></a>     *
<a name="line766"></a>     * @return boolean <code>true</code> if and only if the renaming succeeded;
<a name="line767"></a>     *          <code>false</code> otherwise
<a name="line768"></a>     *
<a name="line769"></a>     * @throws  SecurityException
<a name="line770"></a>     *          If a security manager exists and its <code>{@link
<a name="line771"></a>     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
<a name="line772"></a>     *          method denies write access to either the old or new pathnames
<a name="line773"></a>     *
<a name="line774"></a>     * @throws  NullPointerException
<a name="line775"></a>     *          If parameter <code>dest</code> is <code>null</code>
<a name="line776"></a>     */
<a name="line777"></a>    public function renameTo(File $dest) {
<a name="line778"></a>	return self::$fs->rename($this, $dest);
<a name="line779"></a>    }
<a name="line780"></a>
<a name="line781"></a>    /**
<a name="line782"></a>     * Sets the last-modified time of the file or directory named by this
<a name="line783"></a>     * abstract pathname.
<a name="line784"></a>     *
<a name="line785"></a>     * <p> All platforms support file-modification times to the nearest second,
<a name="line786"></a>     * but some provide more precision.  The argument will be truncated to fit
<a name="line787"></a>     * the supported precision.  If the operation succeeds and no intervening
<a name="line788"></a>     * operations on the file take place, then the next invocation of the
<a name="line789"></a>     * <code>{@link #lastModified}</code> method will return the (possibly
<a name="line790"></a>     * truncated) <code>time</code> argument that was passed to this method.
<a name="line791"></a>     *
<a name="line792"></a>     * @param long $time The new last-modified time, measured in milliseconds since
<a name="line793"></a>     *               the epoch (00:00:00 GMT, January 1, 1970)
<a name="line794"></a>     *
<a name="line795"></a>     * @return boolean <code>true</code> if and only if the operation succeeded;
<a name="line796"></a>     *          <code>false</code> otherwise
<a name="line797"></a>     *
<a name="line798"></a>     * @throws  IllegalArgumentException  If the argument is negative
<a name="line799"></a>     *
<a name="line800"></a>     * @throws  SecurityException
<a name="line801"></a>     *          If a security manager exists and its <code>{@link
<a name="line802"></a>     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
<a name="line803"></a>     *          method denies write access to the named file
<a name="line804"></a>     *
<a name="line805"></a>     * @since 1.2
<a name="line806"></a>     */
<a name="line807"></a>    public function setLastModified($time) {
<a name="line808"></a>	if ($time < 0) throw new IllegalArgumentException("Negative time");
<a name="line809"></a>	return self::$fs->setLastModifiedTime($this, $time);
<a name="line810"></a>    }
<a name="line811"></a>
<a name="line812"></a>    /**
<a name="line813"></a>     * Marks the file or directory named by this abstract pathname so that
<a name="line814"></a>     * only read operations are allowed.  After invoking this method the file
<a name="line815"></a>     * or directory is guaranteed not to change until it is either deleted or
<a name="line816"></a>     * marked to allow write access.  Whether or not a read-only file or
<a name="line817"></a>     * directory may be deleted depends upon the underlying system.
<a name="line818"></a>     *
<a name="line819"></a>     * @return boolean <code>true</code> if and only if the operation succeeded;
<a name="line820"></a>     *          <code>false</code> otherwise
<a name="line821"></a>     *
<a name="line822"></a>     * @throws  SecurityException
<a name="line823"></a>     *          If a security manager exists and its <code>{@link
<a name="line824"></a>     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
<a name="line825"></a>     *          method denies write access to the named file
<a name="line826"></a>     *
<a name="line827"></a>     * @since 1.2
<a name="line828"></a>     */
<a name="line829"></a>    public function setReadOnly() {
<a name="line830"></a>	return self::$fs->setReadOnly($this);
<a name="line831"></a>    }
<a name="line832"></a>
<a name="line833"></a>   /**
<a name="line834"></a>     * Sets the owner's or everybody's write permission for this abstract
<a name="line835"></a>     * pathname.
<a name="line836"></a>     *
<a name="line837"></a>     * @param boolean  writable
<a name="line838"></a>     *          If <code>true</code>, sets the access permission to allow write
<a name="line839"></a>     *          operations; if <code>false</code> to disallow write operations
<a name="line840"></a>     *
<a name="line841"></a>     * @param boolean  ownerOnly
<a name="line842"></a>     *          If <code>true</code>, the write permission applies only to the
<a name="line843"></a>     *          owner's write permission; otherwise, it applies to everybody.  If
<a name="line844"></a>     *          the underlying file system can not distinguish the owner's write
<a name="line845"></a>     *          permission from that of others, then the permission will apply to
<a name="line846"></a>     *          everybody, regardless of this value.
<a name="line847"></a>     *
<a name="line848"></a>     * @return boolean <code>true</code> if and only if the operation succeeded. The
<a name="line849"></a>     *          operation will fail if the user does not have permission to change
<a name="line850"></a>     *          the access permissions of this abstract pathname.
<a name="line851"></a>     *
<a name="line852"></a>     * @throws  SecurityException
<a name="line853"></a>     *          If a security manager exists and its <code>{@link
<a name="line854"></a>     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
<a name="line855"></a>     *          method denies write access to the named file
<a name="line856"></a>     *
<a name="line857"></a>     * @since 1.6
<a name="line858"></a>     */
<a name="line859"></a>    public function setWritable($writable, $ownerOnly = true) {
<a name="line860"></a>	return self::$fs->setPermission($this, FileSystem.ACCESS_WRITE, $writable, $ownerOnly);
<a name="line861"></a>    }
<a name="line862"></a>
<a name="line863"></a>    /**
<a name="line864"></a>     * Sets the owner's or everybody's read permission for this abstract
<a name="line865"></a>     * pathname.
<a name="line866"></a>     *
<a name="line867"></a>     * @param boolean  readable
<a name="line868"></a>     *          If <code>true</code>, sets the access permission to allow read
<a name="line869"></a>     *          operations; if <code>false</code> to disallow read operations
<a name="line870"></a>     *
<a name="line871"></a>     * @param boolean  ownerOnly
<a name="line872"></a>     *          If <code>true</code>, the read permission applies only to the
<a name="line873"></a>     *          owner's read permission; otherwise, it applies to everybody.  If
<a name="line874"></a>     *          the underlying file system can not distinguish the owner's read
<a name="line875"></a>     *          permission from that of others, then the permission will apply to
<a name="line876"></a>     *          everybody, regardless of this value.
<a name="line877"></a>     *
<a name="line878"></a>     * @return boolean <code>true</code> if and only if the operation succeeded.  The
<a name="line879"></a>     *          operation will fail if the user does not have permission to
<a name="line880"></a>     *          change the access permissions of this abstract pathname.  If
<a name="line881"></a>     *          <code>readable</code> is <code>false</code> and the underlying
<a name="line882"></a>     *          file system does not implement a read permission, then the
<a name="line883"></a>     *          operation will fail.
<a name="line884"></a>     *
<a name="line885"></a>     * @throws  SecurityException
<a name="line886"></a>     *          If a security manager exists and its <code>{@link
<a name="line887"></a>     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
<a name="line888"></a>     *          method denies write access to the file
<a name="line889"></a>     *
<a name="line890"></a>     * @since 1.6
<a name="line891"></a>     */
<a name="line892"></a>    public function setReadable($readable, $ownerOnly = true) {
<a name="line893"></a>	return self::$fs->setPermission($this, FileSystem.ACCESS_READ, $readable, $ownerOnly);
<a name="line894"></a>    }
<a name="line895"></a>
<a name="line896"></a>    /**
<a name="line897"></a>     * Sets the owner's or everybody's execute permission for this abstract
<a name="line898"></a>     * pathname.
<a name="line899"></a>     *
<a name="line900"></a>     * @param boolean  executable
<a name="line901"></a>     *          If <code>true</code>, sets the access permission to allow execute
<a name="line902"></a>     *          operations; if <code>false</code> to disallow execute operations
<a name="line903"></a>     *
<a name="line904"></a>     * @param boolean  ownerOnly
<a name="line905"></a>     *          If <code>true</code>, the execute permission applies only to the
<a name="line906"></a>     *          owner's execute permission; otherwise, it applies to everybody.
<a name="line907"></a>     *          If the underlying file system can not distinguish the owner's
<a name="line908"></a>     *          execute permission from that of others, then the permission will
<a name="line909"></a>     *          apply to everybody, regardless of this value.
<a name="line910"></a>     *
<a name="line911"></a>     * @return boolean <code>true</code> if and only if the operation succeeded.  The
<a name="line912"></a>     *          operation will fail if the user does not have permission to
<a name="line913"></a>     *          change the access permissions of this abstract pathname.  If
<a name="line914"></a>     *          <code>executable</code> is <code>false</code> and the underlying
<a name="line915"></a>     *          file system does not implement an execute permission, then the
<a name="line916"></a>     *          operation will fail.
<a name="line917"></a>     *
<a name="line918"></a>     * @throws  SecurityException
<a name="line919"></a>     *          If a security manager exists and its <code>{@link
<a name="line920"></a>     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
<a name="line921"></a>     *          method denies write access to the file
<a name="line922"></a>     *
<a name="line923"></a>     * @since 1.6
<a name="line924"></a>     */
<a name="line925"></a>    public function setExecutable($executable, $ownerOnly = true) {
<a name="line926"></a>	return self::$fs->setPermission($this, FileSystem.ACCESS_EXECUTE, $executable, $ownerOnly);
<a name="line927"></a>    }
<a name="line928"></a>
<a name="line929"></a>    /**
<a name="line930"></a>     * Tests whether the application can execute the file denoted by this
<a name="line931"></a>     * abstract pathname.
<a name="line932"></a>     *
<a name="line933"></a>     * @return boolean <code>true</code> if and only if the abstract pathname exists
<a name="line934"></a>     *          <em>and</em> the application is allowed to execute the file
<a name="line935"></a>     *
<a name="line936"></a>     * @throws  SecurityException
<a name="line937"></a>     *          If a security manager exists and its <code>{@link
<a name="line938"></a>     *          java.lang.SecurityManager#checkExec(java.lang.String)}</code>
<a name="line939"></a>     *          method denies execute access to the file
<a name="line940"></a>     *
<a name="line941"></a>     * @since 1.6
<a name="line942"></a>     */
<a name="line943"></a>    public function canExecute() {
<a name="line944"></a>	return self::$fs->checkAccess($this, FileSystem::ACCESS_EXECUTE);
<a name="line945"></a>    }
<a name="line946"></a>
<a name="line947"></a>
<a name="line948"></a>    /* -- Filesystem interface -- */
<a name="line949"></a>
<a name="line950"></a>    /**
<a name="line951"></a>     * List the available filesystem roots.
<a name="line952"></a>     *
<a name="line953"></a>     * <p> A particular Java platform may support zero or more
<a name="line954"></a>     * hierarchically-organized file systems.  Each file system has a
<a name="line955"></a>     * <code>root</code> directory from which all other files in that file
<a name="line956"></a>     * system can be reached.  Windows platforms, for example, have a root
<a name="line957"></a>     * directory for each active drive; UNIX platforms have a single root
<a name="line958"></a>     * directory, namely <code>"/"</code>.  The set of available filesystem
<a name="line959"></a>     * roots is affected by various system-level operations such as the insertion
<a name="line960"></a>     * or ejection of removable media and the disconnecting or unmounting of
<a name="line961"></a>     * physical or virtual disk drives.
<a name="line962"></a>     *
<a name="line963"></a>     * <p> This method returns an array of <code>File</code> objects that
<a name="line964"></a>     * denote the root directories of the available filesystem roots.  It is
<a name="line965"></a>     * guaranteed that the canonical pathname of any file physically present on
<a name="line966"></a>     * the local machine will begin with one of the roots returned by this
<a name="line967"></a>     * method.
<a name="line968"></a>     *
<a name="line969"></a>     * <p> The canonical pathname of a file that resides on some other machine
<a name="line970"></a>     * and is accessed via a remote-filesystem protocol such as SMB or NFS may
<a name="line971"></a>     * or may not begin with one of the roots returned by this method.  If the
<a name="line972"></a>     * pathname of a remote file is syntactically indistinguishable from the
<a name="line973"></a>     * pathname of a local file then it will begin with one of the roots
<a name="line974"></a>     * returned by this method.  Thus, for example, <code>File</code> objects
<a name="line975"></a>     * denoting the root directories of the mapped network drives of a Windows
<a name="line976"></a>     * platform will be returned by this method, while <code>File</code>
<a name="line977"></a>     * objects containing UNC pathnames will not be returned by this method.
<a name="line978"></a>     *
<a name="line979"></a>     * <p> Unlike most methods in this class, this method does not throw
<a name="line980"></a>     * security exceptions.  If a security manager exists and its <code>{@link
<a name="line981"></a>     * java.lang.SecurityManager#checkRead(java.lang.String)}</code> method
<a name="line982"></a>     * denies read access to a particular root directory, then that directory
<a name="line983"></a>     * will not appear in the result.
<a name="line984"></a>     *
<a name="line985"></a>     * @return array[blaze\io\File] An array of <code>File</code> objects denoting the available
<a name="line986"></a>     *          filesystem roots, or <code>null</code> if the set of roots
<a name="line987"></a>     *          could not be determined.  The array will be empty if there are
<a name="line988"></a>     *          no filesystem roots.
<a name="line989"></a>     *
<a name="line990"></a>     * @since 1.2
<a name="line991"></a>     */
<a name="line992"></a>    public static function listRoots() {
<a name="line993"></a>	return self::$fs->listRoots();
<a name="line994"></a>    }
<a name="line995"></a>
<a name="line996"></a>
<a name="line997"></a>    /* -- Disk usage -- */
<a name="line998"></a>
<a name="line999"></a>    /**
<a name="line1000"></a>     * Returns the size of the partition <a href="#partName">named</a> by this
<a name="line1001"></a>     * abstract pathname.
<a name="line1002"></a>     *
<a name="line1003"></a>     * @return long The size, in bytes, of the partition or <tt>0L</tt> if this
<a name="line1004"></a>     *          abstract pathname does not name a partition
<a name="line1005"></a>     *
<a name="line1006"></a>     * @throws  SecurityException
<a name="line1007"></a>     *          If a security manager has been installed and it denies
<a name="line1008"></a>     *          {@link RuntimePermission}<tt>("getFileSystemAttributes")</tt>
<a name="line1009"></a>     *          or its {@link SecurityManager#checkRead(String)} method denies
<a name="line1010"></a>     *          read access to the file named by this abstract pathname
<a name="line1011"></a>     *
<a name="line1012"></a>     * @since  1.6
<a name="line1013"></a>     */
<a name="line1014"></a>    public function getTotalSpace() {
<a name="line1015"></a>	return self::$fs->getSpace($this,FileSystem::SPACE_TOTAL);
<a name="line1016"></a>    }
<a name="line1017"></a>
<a name="line1018"></a>    /**
<a name="line1019"></a>     * Returns the number of unallocated bytes in the partition <a
<a name="line1020"></a>     * href="#partName">named</a> by this abstract path name.
<a name="line1021"></a>     *
<a name="line1022"></a>     * <p> The returned number of unallocated bytes is a hint, but not
<a name="line1023"></a>     * a guarantee, that it is possible to use most or any of these
<a name="line1024"></a>     * bytes.  The number of unallocated bytes is most likely to be
<a name="line1025"></a>     * accurate immediately after this call.  It is likely to be made
<a name="line1026"></a>     * inaccurate by any external I/O operations including those made
<a name="line1027"></a>     * on the system outside of this virtual machine.  This method
<a name="line1028"></a>     * makes no guarantee that write operations to this file system
<a name="line1029"></a>     * will succeed.
<a name="line1030"></a>     *
<a name="line1031"></a>     * @return long The number of unallocated bytes on the partition <tt>0L</tt>
<a name="line1032"></a>     *          if the abstract pathname does not name a partition.  This
<a name="line1033"></a>     *          value will be less than or equal to the total file system size
<a name="line1034"></a>     *          returned by {@link #getTotalSpace}.
<a name="line1035"></a>     *
<a name="line1036"></a>     * @throws  SecurityException
<a name="line1037"></a>     *          If a security manager has been installed and it denies
<a name="line1038"></a>     *          {@link RuntimePermission}<tt>("getFileSystemAttributes")</tt>
<a name="line1039"></a>     *          or its {@link SecurityManager#checkRead(String)} method denies
<a name="line1040"></a>     *          read access to the file named by this abstract pathname
<a name="line1041"></a>     *
<a name="line1042"></a>     * @since  1.6
<a name="line1043"></a>     */
<a name="line1044"></a>    public function getFreeSpace() {
<a name="line1045"></a>	return self::$fs->getFreeSpace($this,FileSystem::SPACE_FREE);
<a name="line1046"></a>    }
<a name="line1047"></a>
<a name="line1048"></a>    /**
<a name="line1049"></a>     * Returns the number of bytes available to this virtual machine on the
<a name="line1050"></a>     * partition <a href="#partName">named</a> by this abstract pathname.  When
<a name="line1051"></a>     * possible, this method checks for write permissions and other operating
<a name="line1052"></a>     * system restrictions and will therefore usually provide a more accurate
<a name="line1053"></a>     * estimate of how much new data can actually be written than {@link
<a name="line1054"></a>     * #getFreeSpace}.
<a name="line1055"></a>     *
<a name="line1056"></a>     * <p> The returned number of available bytes is a hint, but not a
<a name="line1057"></a>     * guarantee, that it is possible to use most or any of these bytes.  The
<a name="line1058"></a>     * number of unallocated bytes is most likely to be accurate immediately
<a name="line1059"></a>     * after this call.  It is likely to be made inaccurate by any external
<a name="line1060"></a>     * I/O operations including those made on the system outside of this
<a name="line1061"></a>     * virtual machine.  This method makes no guarantee that write operations
<a name="line1062"></a>     * to this file system will succeed.
<a name="line1063"></a>     *
<a name="line1064"></a>     * @return long The number of available bytes on the partition or <tt>0L</tt>
<a name="line1065"></a>     *          if the abstract pathname does not name a partition.  On
<a name="line1066"></a>     *          systems where this information is not available, this method
<a name="line1067"></a>     *          will be equivalent to a call to {@link #getFreeSpace}.
<a name="line1068"></a>     *
<a name="line1069"></a>     * @throws  SecurityException
<a name="line1070"></a>     *          If a security manager has been installed and it denies
<a name="line1071"></a>     *          {@link RuntimePermission}<tt>("getFileSystemAttributes")</tt>
<a name="line1072"></a>     *          or its {@link SecurityManager#checkRead(String)} method denies
<a name="line1073"></a>     *          read access to the file named by this abstract pathname
<a name="line1074"></a>     *
<a name="line1075"></a>     * @since  1.6
<a name="line1076"></a>     */
<a name="line1077"></a>    public function getUsableSpace() {
<a name="line1078"></a>	return self::$fs->getUsableSpace($this,FileSystem::SPACE_USABLE);
<a name="line1079"></a>    }
<a name="line1080"></a>
<a name="line1081"></a>
<a name="line1082"></a>    /* -- Temporary files -- */
<a name="line1083"></a>
<a name="line1084"></a>    //private static final Object tmpFileLock = new Object();
<a name="line1085"></a>
<a name="line1086"></a>    /**
<a name="line1087"></a>     * @var integer
<a name="line1088"></a>     */
<a name="line1089"></a>    private static $counter = -1; /* Protected by tmpFileLock */
<a name="line1090"></a>
<a name="line1091"></a>    /**
<a name="line1092"></a>     * @param string $prefix
<a name="line1093"></a>     * @param string $suffix
<a name="line1094"></a>     * @param blaze\lang\File $dir
<a name="line1095"></a>     * @return blaze\lang\File
<a name="line1096"></a>     */
<a name="line1097"></a>
<a name="line1098"></a>    private static function generateFile($prefix, $suffix, File $dir)
<a name="line1099"></a>	//throws IOException
<a name="line1100"></a>    {
<a name="line1101"></a>	if ($counter == -1) {
<a name="line1102"></a>            $r = new Random();
<a name="line1103"></a>	    $counter = $r->nextInt() & 0xffff;
<a name="line1104"></a>	}
<a name="line1105"></a>	$counter++;
<a name="line1106"></a>	return new File($dir, $prefix . $counter . $suffix);
<a name="line1107"></a>    }
<a name="line1108"></a>
<a name="line1109"></a>    private static $tmpdir;
<a name="line1110"></a>
<a name="line1111"></a>    /**
<a name="line1112"></a>     * @return string
<a name="line1113"></a>     */
<a name="line1114"></a>
<a name="line1115"></a>    private static function getTempDir() {
<a name="line1116"></a>	if (self::$tmpdir == null) {
<a name="line1117"></a>            self::$tmpdir = self::$fs->normalize(sys_get_temp_dir());
<a name="line1118"></a>	}
<a name="line1119"></a>	return self::$tmpdir;
<a name="line1120"></a>    }
<a name="line1121"></a>
<a name="line1122"></a>    /**
<a name="line1123"></a>     * @return boolean
<a name="line1124"></a>     */
<a name="line1125"></a>
<a name="line1126"></a>//    private static boolean checkAndCreate(String filename, SecurityManager sm)
<a name="line1127"></a>//	throws IOException
<a name="line1128"></a>//    {
<a name="line1129"></a>//	if (sm != null) {
<a name="line1130"></a>//	    try {
<a name="line1131"></a>//		sm.checkWrite(filename);
<a name="line1132"></a>//	    } catch (AccessControlException x) {
<a name="line1133"></a>//		/* Throwing the original AccessControlException could disclose
<a name="line1134"></a>//		   the location of the default temporary directory, so we
<a name="line1135"></a>//		   re-throw a more innocuous SecurityException */
<a name="line1136"></a>//		throw new SecurityException("Unable to create temporary file");
<a name="line1137"></a>//	    }
<a name="line1138"></a>//	}
<a name="line1139"></a>//	return fs.createFileExclusively(filename);
<a name="line1140"></a>//    }
<a name="line1141"></a>
<a name="line1142"></a>    /**
<a name="line1143"></a>     * <p> Creates a new empty file in the specified directory, using the
<a name="line1144"></a>     * given prefix and suffix strings to generate its name.  If this method
<a name="line1145"></a>     * returns successfully then it is guaranteed that:
<a name="line1146"></a>     *
<a name="line1147"></a>     * <ol>
<a name="line1148"></a>     * <li> The file denoted by the returned abstract pathname did not exist
<a name="line1149"></a>     *      before this method was invoked, and
<a name="line1150"></a>     * <li> Neither this method nor any of its variants will return the same
<a name="line1151"></a>     *      abstract pathname again in the current invocation of the virtual
<a name="line1152"></a>     *      machine.
<a name="line1153"></a>     * </ol>
<a name="line1154"></a>     *
<a name="line1155"></a>     * This method provides only part of a temporary-file facility.  To arrange
<a name="line1156"></a>     * for a file created by this method to be deleted automatically, use the
<a name="line1157"></a>     * <code>{@link #deleteOnExit}</code> method.
<a name="line1158"></a>     *
<a name="line1159"></a>     * <p> The <code>prefix</code> argument must be at least three characters
<a name="line1160"></a>     * long.  It is recommended that the prefix be a short, meaningful string
<a name="line1161"></a>     * such as <code>"hjb"</code> or <code>"mail"</code>.  The
<a name="line1162"></a>     * <code>suffix</code> argument may be <code>null</code>, in which case the
<a name="line1163"></a>     * suffix <code>".tmp"</code> will be used.
<a name="line1164"></a>     *
<a name="line1165"></a>     * <p> To create the new file, the prefix and the suffix may first be
<a name="line1166"></a>     * adjusted to fit the limitations of the underlying platform.  If the
<a name="line1167"></a>     * prefix is too long then it will be truncated, but its first three
<a name="line1168"></a>     * characters will always be preserved.  If the suffix is too long then it
<a name="line1169"></a>     * too will be truncated, but if it begins with a period character
<a name="line1170"></a>     * (<code>'.'</code>) then the period and the first three characters
<a name="line1171"></a>     * following it will always be preserved.  Once these adjustments have been
<a name="line1172"></a>     * made the name of the new file will be generated by concatenating the
<a name="line1173"></a>     * prefix, five or more internally-generated characters, and the suffix.
<a name="line1174"></a>     *
<a name="line1175"></a>     * <p> If the <code>directory</code> argument is <code>null</code> then the
<a name="line1176"></a>     * system-dependent default temporary-file directory will be used.  The
<a name="line1177"></a>     * default temporary-file directory is specified by the system property
<a name="line1178"></a>     * <code>java.io.tmpdir</code>.  On UNIX systems the default value of this
<a name="line1179"></a>     * property is typically <code>"/tmp"</code> or <code>"/var/tmp"</code>; on
<a name="line1180"></a>     * Microsoft Windows systems it is typically <code>"C:\\WINNT\\TEMP"</code>.  A different
<a name="line1181"></a>     * value may be given to this system property when the Java virtual machine
<a name="line1182"></a>     * is invoked, but programmatic changes to this property are not guaranteed
<a name="line1183"></a>     * to have any effect upon the temporary directory used by this method.
<a name="line1184"></a>     *
<a name="line1185"></a>     * @param  prefix     The prefix string to be used in generating the file's
<a name="line1186"></a>     *                    name; must be at least three characters long
<a name="line1187"></a>     *
<a name="line1188"></a>     * @param  suffix     The suffix string to be used in generating the file's
<a name="line1189"></a>     *                    name; may be <code>null</code>, in which case the
<a name="line1190"></a>     *                    suffix <code>".tmp"</code> will be used
<a name="line1191"></a>     *
<a name="line1192"></a>     * @param  directory  The directory in which the file is to be created, or
<a name="line1193"></a>     *                    <code>null</code> if the default temporary-file
<a name="line1194"></a>     *                    directory is to be used
<a name="line1195"></a>     *
<a name="line1196"></a>     * @return blaze\lang\File An abstract pathname denoting a newly-created empty file
<a name="line1197"></a>     *
<a name="line1198"></a>     * @throws  IllegalArgumentException
<a name="line1199"></a>     *          If the <code>prefix</code> argument contains fewer than three
<a name="line1200"></a>     *          characters
<a name="line1201"></a>     *
<a name="line1202"></a>     * @throws  IOException  If a file could not be created
<a name="line1203"></a>     *
<a name="line1204"></a>     * @throws  SecurityException
<a name="line1205"></a>     *          If a security manager exists and its <code>{@link
<a name="line1206"></a>     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
<a name="line1207"></a>     *          method does not allow a file to be created
<a name="line1208"></a>     *
<a name="line1209"></a>     * @since 1.2
<a name="line1210"></a>     */
<a name="line1211"></a>    public static function createTempFile($prefix, $suffix,
<a name="line1212"></a>				      File $directory = null)
<a name="line1213"></a>        //throws IOException
<a name="line1214"></a>    {
<a name="line1215"></a>//	if (prefix == null) throw new NullPointerException();
<a name="line1216"></a>//	if (prefix.length() < 3)
<a name="line1217"></a>//	    throw new IllegalArgumentException("Prefix string too short");
<a name="line1218"></a>//	String s = (suffix == null) ? ".tmp" : suffix;
<a name="line1219"></a>//	synchronized (tmpFileLock) {
<a name="line1220"></a>//	    if (directory == null) {
<a name="line1221"></a>//                String tmpDir = getTempDir();
<a name="line1222"></a>//		directory = new File(tmpDir, fs.prefixLength(tmpDir));
<a name="line1223"></a>//	    }
<a name="line1224"></a>//	    SecurityManager sm = System.getSecurityManager();
<a name="line1225"></a>//	    File f;
<a name="line1226"></a>//	    do {
<a name="line1227"></a>//		f = generateFile(prefix, s, directory);
<a name="line1228"></a>//	    } while (!checkAndCreate(f.getPath(), sm));
<a name="line1229"></a>//	    return f;
<a name="line1230"></a>//	}
<a name="line1231"></a>    }
<a name="line1232"></a>
<a name="line1233"></a>
<a name="line1234"></a>
<a name="line1235"></a>    /* -- Basic infrastructure -- */
<a name="line1236"></a>
<a name="line1237"></a>    /**
<a name="line1238"></a>     * Compares two abstract pathnames lexicographically.  The ordering
<a name="line1239"></a>     * defined by this method depends upon the underlying system.  On UNIX
<a name="line1240"></a>     * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
<a name="line1241"></a>     * systems it is not.
<a name="line1242"></a>     *
<a name="line1243"></a>     * @param   pathname  The abstract pathname to be compared to this abstract
<a name="line1244"></a>     *                    pathname
<a name="line1245"></a>     *
<a name="line1246"></a>     * @return integer Zero if the argument is equal to this abstract pathname, a
<a name="line1247"></a>     *		value less than zero if this abstract pathname is
<a name="line1248"></a>     *		lexicographically less than the argument, or a value greater
<a name="line1249"></a>     *		than zero if this abstract pathname is lexicographically
<a name="line1250"></a>     *		greater than the argument
<a name="line1251"></a>     *
<a name="line1252"></a>     * @since   1.2
<a name="line1253"></a>     */
<a name="line1254"></a>    public function compareTo(Object $pathname) {
<a name="line1255"></a>        if(!$pathname instanceof File)
<a name="line1256"></a>            throw new ClassCastException();
<a name="line1257"></a>	return strcmp($this->path, $pathname);
<a name="line1258"></a>    }
<a name="line1259"></a>
<a name="line1260"></a>    /**
<a name="line1261"></a>     * Tests this abstract pathname for equality with the given object.
<a name="line1262"></a>     * Returns <code>true</code> if and only if the argument is not
<a name="line1263"></a>     * <code>null</code> and is an abstract pathname that denotes the same file
<a name="line1264"></a>     * or directory as this abstract pathname.  Whether or not two abstract
<a name="line1265"></a>     * pathnames are equal depends upon the underlying system.  On UNIX
<a name="line1266"></a>     * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
<a name="line1267"></a>     * systems it is not.
<a name="line1268"></a>     *
<a name="line1269"></a>     * @param   obj   The object to be compared with this abstract pathname
<a name="line1270"></a>     *
<a name="line1271"></a>     * @return boolean  <code>true</code> if and only if the objects are the same;
<a name="line1272"></a>     *                  <code>false</code> otherwise
<a name="line1273"></a>     */
<a name="line1274"></a>    public function equals(\blaze\lang\Reflectable $obj) {
<a name="line1275"></a>	if (($obj != null) && ($obj instanceof File)) {
<a name="line1276"></a>	    return $this->compareTo($obj) == 0;
<a name="line1277"></a>	}
<a name="line1278"></a>	return false;
<a name="line1279"></a>    }
<a name="line1280"></a>
<a name="line1281"></a>    /**
<a name="line1282"></a>     * Computes a hash code for this abstract pathname.  Because equality of
<a name="line1283"></a>     * abstract pathnames is inherently system-dependent, so is the computation
<a name="line1284"></a>     * of their hash codes.  On UNIX systems, the hash code of an abstract
<a name="line1285"></a>     * pathname is equal to the exclusive <em>or</em> of the hash code
<a name="line1286"></a>     * of its pathname string and the decimal value
<a name="line1287"></a>     * <code>1234321</code>.  On Microsoft Windows systems, the hash
<a name="line1288"></a>     * code is equal to the exclusive <em>or</em> of the hash code of
<a name="line1289"></a>     * its pathname string converted to lower case and the decimal
<a name="line1290"></a>     * value <code>1234321</code>.  Locale is not taken into account on
<a name="line1291"></a>     * lowercasing the pathname string.
<a name="line1292"></a>     *
<a name="line1293"></a>     * @return string A hash code for this abstract pathname
<a name="line1294"></a>     */
<a name="line1295"></a>    public function hashCode() {
<a name="line1296"></a>	return md5($this->getAbsolutePath());
<a name="line1297"></a>    }
<a name="line1298"></a>
<a name="line1299"></a>    /**
<a name="line1300"></a>     * Returns the pathname string of this abstract pathname.  This is just the
<a name="line1301"></a>     * string returned by the <code>{@link #getPath}</code> method.
<a name="line1302"></a>     *
<a name="line1303"></a>     * @return string The string form of this abstract pathname
<a name="line1304"></a>     */
<a name="line1305"></a>    public function __toString() {
<a name="line1306"></a>	return $this->path->toNative();
<a name="line1307"></a>    }
<a name="line1308"></a>
<a name="line1309"></a>
<a name="line1310"></a>    /**
<a name="line1311"></a>     * WriteObject is called to save this filename.
<a name="line1312"></a>     * The separator character is saved also so it can be replaced
<a name="line1313"></a>     * in case the path is reconstituted on a different host type.
<a name="line1314"></a>     * <p>
<a name="line1315"></a>     * @serialData  Default fields followed by separator character.
<a name="line1316"></a>     */
<a name="line1317"></a>//    private synchronized void writeObject(java.io.ObjectOutputStream s)
<a name="line1318"></a>//        throws IOException
<a name="line1319"></a>//    {
<a name="line1320"></a>//	s.defaultWriteObject();
<a name="line1321"></a>//	s.writeChar(this.separatorChar); // Add the separator character
<a name="line1322"></a>//    }
<a name="line1323"></a>
<a name="line1324"></a>    /**
<a name="line1325"></a>     * readObject is called to restore this filename.
<a name="line1326"></a>     * The original separator character is read.  If it is different
<a name="line1327"></a>     * than the separator character on this system, then the old separator
<a name="line1328"></a>     * is replaced by the local separator.
<a name="line1329"></a>     */
<a name="line1330"></a>//    private synchronized void readObject(java.io.ObjectInputStream s)
<a name="line1331"></a>//         throws IOException, ClassNotFoundException
<a name="line1332"></a>//    {
<a name="line1333"></a>//    }
<a name="line1334"></a>}
<a name="line1335"></a>
<a name="line1336"></a>?>
<a name="line1337"></a></pre>
<div class="header">
<h1>Blaze Framework</h1>
<ul>
<li><a href="../overview-summary.html">Overview</a></li>
<li>Package</li><li>Class</li><li>Tree</li><li><a href="../overview-files.html">Files</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
</ul>
</div>

<div class="small_links">
<a href="../index.html" target="_top">Frames</a>
<a href="../source\blaze\io\file.php.html" target="_top">No frames</a>
</div>
<hr>

<p id="footer">This document was generated by <a href="http://peej.github.com/phpdoctor/">PHPDoctor: The PHP Documentation Creator</a></p>

</body>

</html>