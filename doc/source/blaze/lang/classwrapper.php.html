<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="PHPDoctor 2RC4 (http://peej.github.com/phpdoctor/)">
<meta name="when" content="Mon, 09 Aug 2010 18:21:11 +0000">

<link rel="stylesheet" type="text/css" href="../stylesheet.css">
<link rel="start" href="../overview-summary.html">

<title>blaze\lang\ClassWrapper.php (Blaze Framework)</title>

</head>
<body id="file" onload="parent.document.title=document.title;">

<div class="header">
<h1>Blaze Framework</h1>
<ul>
<li><a href="../overview-summary.html">Overview</a></li>
<li>Package</li><li>Class</li><li>Tree</li><li><a href="../overview-files.html">Files</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
</ul>
</div>

<div class="small_links">
<a href="../index.html" target="_top">Frames</a>
<a href="../source\blaze\lang\classwrapper.php.html" target="_top">No frames</a>
</div>
<hr>

<h1>blaze\lang\ClassWrapper.php</h1>
<hr>

<a name="line1"></a><pre><?php
<a name="line2"></a>namespace blaze\lang;
<a name="line3"></a>use \ReflectionClass,
<a name="line4"></a>	blaze\util\ArrayObject,
<a name="line5"></a>	blaze\lang\reflect\Method,
<a name="line6"></a>	blaze\lang\reflect\Field,
<a name="line7"></a>	blaze\io\Serializable;
<a name="line8"></a>
<a name="line9"></a>/**
<a name="line10"></a> * Instances of the class ClassWrapper represent classes, interfaces and enumerations which are classes too.
<a name="line11"></a> * Native datatypes can only be 
<a name="line12"></a> *
<a name="line13"></a> * @license http://www.opensource.org/licenses/gpl-3.0.html GPL
<a name="line14"></a> * @link    http://blazeframework.sourceforge.net
<a name="line15"></a> * @since   1.0
<a name="line16"></a> * @version $Revision$
<a name="line17"></a> * @author  Christian Beikov
<a name="line18"></a> * @todo    Documentations is missing
<a name="line19"></a> */
<a name="line20"></a>final class ClassWrapper extends Object implements Serializable{
<a name="line21"></a>    /**
<a name="line22"></a>     *
<a name="line23"></a>     * @var \ReflectionClass
<a name="line24"></a>     */
<a name="line25"></a>    private $reflectionClass;
<a name="line26"></a>
<a name="line27"></a>    private function __construct($class){
<a name="line28"></a>        //parent::__construct();
<a name="line29"></a>        $this->reflectionClass = $class;
<a name="line30"></a>    }
<a name="line31"></a>
<a name="line32"></a>    /**
<a name="line33"></a>     * Converts the object to a string. The string representation is the
<a name="line34"></a>     * string "class" or "interface", followed by a space, and then by the
<a name="line35"></a>     * fully qualified name of the class in the format returned by
<a name="line36"></a>     * <code>getName</code>.  If this <code>Class</code> object represents a
<a name="line37"></a>     * primitive type, this method returns the name of the primitive type.  If
<a name="line38"></a>     * this <code>Class</code> object represents void this method returns
<a name="line39"></a>     * "void".
<a name="line40"></a>     *
<a name="line41"></a>     * @return string a string representation of this class object.
<a name="line42"></a>     */
<a name="line43"></a>    public function __toString(){
<a name="line44"></a>        return ($this->isInterface() ? "interface " : ($this->isPrimitive() ? "" : "class ")). $this->getName();
<a name="line45"></a>    }
<a name="line46"></a>
<a name="line47"></a>    /**
<a name="line48"></a>     * Returns the <code>Class</code> object associated with the class or
<a name="line49"></a>     * interface with the given string name.  Invoking this method is
<a name="line50"></a>     * equivalent to:
<a name="line51"></a>     *
<a name="line52"></a>     * <blockquote><pre>
<a name="line53"></a>     *  Class.forName(className, true, currentLoader)
<a name="line54"></a>     * </pre></blockquote>
<a name="line55"></a>     *
<a name="line56"></a>     * where <code>currentLoader</code> denotes the defining class loader of
<a name="line57"></a>     * the current class.
<a name="line58"></a>     *
<a name="line59"></a>     * <p> For example, the following code fragment returns the
<a name="line60"></a>     * runtime <code>Class</code> descriptor for the class named
<a name="line61"></a>     * <code>java.lang.Thread</code>:
<a name="line62"></a>     *
<a name="line63"></a>     * <blockquote><pre>
<a name="line64"></a>     *   Class&nbsp;t&nbsp;= Class.forName("java.lang.Thread")
<a name="line65"></a>     * </pre></blockquote>
<a name="line66"></a>     * <p>
<a name="line67"></a>     * A call to <tt>forName("X")</tt> causes the class named
<a name="line68"></a>     * <tt>X</tt> to be initialized.
<a name="line69"></a>     *
<a name="line70"></a>     * @param blaze\lang\String|string $className   the fully qualified name of the desired class.
<a name="line71"></a>     * @return blaze\lang\ClassWrapper   ClassWrapper the <code>Class</code> object for the class with the
<a name="line72"></a>     *             specified name.
<a name="line73"></a>     * @exception LinkageError if the linkage fails
<a name="line74"></a>     * @exception ExceptionInInitializerError if the initialization provoked
<a name="line75"></a>     *            by this method fails
<a name="line76"></a>     * @exception ClassNotFoundException if the class cannot be located
<a name="line77"></a>     */
<a name="line78"></a>    public static function forName($className){
<a name="line79"></a>        $className = String::asNative($className);
<a name="line80"></a>        $reflection = new ReflectionClass($className);
<a name="line81"></a>
<a name="line82"></a>        if(!$reflection->isSubclassOf('blaze\lang\Reflectable') && $reflection->getName() != 'blaze\lang\Reflectable')
<a name="line83"></a>            throw new IllegalArgumentException('Reflection only works for classes which implement blaze\lang\Reflectable');
<a name="line84"></a>        return new self($reflection, false);
<a name="line85"></a>    }
<a name="line86"></a>
<a name="line87"></a>    /**
<a name="line88"></a>     * Creates a new instance of the class represented by this <tt>Class</tt>
<a name="line89"></a>     * object.  The class is instantiated as if by a <code>new</code>
<a name="line90"></a>     * expression with an empty argument list.  The class is initialized if it
<a name="line91"></a>     * has not already been initialized.
<a name="line92"></a>     *
<a name="line93"></a>     * <p>Note that this method propagates any exception thrown by the
<a name="line94"></a>     * nullary constructor, including a checked exception.  Use of
<a name="line95"></a>     * this method effectively bypasses the compile-time exception
<a name="line96"></a>     * checking that would otherwise be performed by the compiler.
<a name="line97"></a>     * The {@link
<a name="line98"></a>     * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
<a name="line99"></a>     * Constructor.newInstance} method avoids this problem by wrapping
<a name="line100"></a>     * any exception thrown by the constructor in a (checked) {@link
<a name="line101"></a>     * java.lang.reflect.InvocationTargetException}.
<a name="line102"></a>     *
<a name="line103"></a>     * @return     a newly allocated instance of the class represented by this
<a name="line104"></a>     *             object.
<a name="line105"></a>     * @exception  IllegalAccessException  if the class or its nullary
<a name="line106"></a>     *               constructor is not accessible.
<a name="line107"></a>     * @exception  InstantiationException
<a name="line108"></a>     *               if this <code>Class</code> represents an abstract class,
<a name="line109"></a>     *               an interface, an array class, a primitive type, or void;
<a name="line110"></a>     *               or if the class has no nullary constructor;
<a name="line111"></a>     *               or if the instantiation fails for some other reason.
<a name="line112"></a>     * @exception  ExceptionInInitializerError if the initialization
<a name="line113"></a>     *               provoked by this method fails.
<a name="line114"></a>     * @exception  SecurityException
<a name="line115"></a>     *             If a security manager, <i>s</i>, is present and any of the
<a name="line116"></a>     *             following conditions is met:
<a name="line117"></a>     *
<a name="line118"></a>     *             <ul>
<a name="line119"></a>     *
<a name="line120"></a>     *             <li> invocation of
<a name="line121"></a>     *             <tt>{@link SecurityManager#checkMemberAccess
<a name="line122"></a>     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
<a name="line123"></a>     *             creation of new instances of this class
<a name="line124"></a>     *
<a name="line125"></a>     *             <li> the caller's class loader is not the same as or an
<a name="line126"></a>     *             ancestor of the class loader for the current class and
<a name="line127"></a>     *             invocation of <tt>{@link SecurityManager#checkPackageAccess
<a name="line128"></a>     *             s.checkPackageAccess()}</tt> denies access to the package
<a name="line129"></a>     *             of this class
<a name="line130"></a>     *
<a name="line131"></a>     *             </ul>
<a name="line132"></a>     *
<a name="line133"></a>     */
<a name="line134"></a>    public function newInstance($args = null){
<a name="line135"></a>        if(is_array($args))
<a name="line136"></a>            return $this->reflectionClass->newInstance($args);
<a name="line137"></a>        else
<a name="line138"></a>            return $this->reflectionClass->newInstance(null);
<a name="line139"></a>    }
<a name="line140"></a>
<a name="line141"></a>    /**
<a name="line142"></a>     * Determines if the specified <code>Object</code> is assignment-compatible
<a name="line143"></a>     * with the object represented by this <code>Class</code>.  This method is
<a name="line144"></a>     * the dynamic equivalent of the Java language <code>instanceof</code>
<a name="line145"></a>     * operator. The method returns <code>true</code> if the specified
<a name="line146"></a>     * <code>Object</code> argument is non-null and can be cast to the
<a name="line147"></a>     * reference type represented by this <code>Class</code> object without
<a name="line148"></a>     * raising a <code>ClassCastException.</code> It returns <code>false</code>
<a name="line149"></a>     * otherwise.
<a name="line150"></a>     *
<a name="line151"></a>     * <p> Specifically, if this <code>Class</code> object represents a
<a name="line152"></a>     * declared class, this method returns <code>true</code> if the specified
<a name="line153"></a>     * <code>Object</code> argument is an instance of the represented class (or
<a name="line154"></a>     * of any of its subclasses); it returns <code>false</code> otherwise. If
<a name="line155"></a>     * this <code>Class</code> object represents an array class, this method
<a name="line156"></a>     * returns <code>true</code> if the specified <code>Object</code> argument
<a name="line157"></a>     * can be converted to an object of the array class by an identity
<a name="line158"></a>     * conversion or by a widening reference conversion; it returns
<a name="line159"></a>     * <code>false</code> otherwise. If this <code>Class</code> object
<a name="line160"></a>     * represents an interface, this method returns <code>true</code> if the
<a name="line161"></a>     * class or any superclass of the specified <code>Object</code> argument
<a name="line162"></a>     * implements this interface; it returns <code>false</code> otherwise. If
<a name="line163"></a>     * this <code>Class</code> object represents a primitive type, this method
<a name="line164"></a>     * returns <code>false</code>.
<a name="line165"></a>     *
<a name="line166"></a>     * @param   obj the object to check
<a name="line167"></a>     * @return boolean true if <code>obj</code> is an instance of this class
<a name="line168"></a>     *
<a name="line169"></a>     * @since JDK1.1
<a name="line170"></a>     */
<a name="line171"></a>    public function isInstance(Reflectable $obj){
<a name="line172"></a>        return $this->reflectionClass->isInstance($obj);
<a name="line173"></a>    }
<a name="line174"></a>
<a name="line175"></a>    /**
<a name="line176"></a>     * Determines if the specified <code>Class</code> object represents an
<a name="line177"></a>     * interface type.
<a name="line178"></a>     *
<a name="line179"></a>     * @return  <code>true</code> if this object represents an interface;
<a name="line180"></a>     *          <code>false</code> otherwise.
<a name="line181"></a>     */
<a name="line182"></a>    public function isInterface(){
<a name="line183"></a>        return $this->reflectionClass->isInterface();
<a name="line184"></a>    }
<a name="line185"></a>
<a name="line186"></a>    /**
<a name="line187"></a>     * Determines if this <code>Class</code> object represents an array class.
<a name="line188"></a>     *
<a name="line189"></a>     * @return  <code>true</code> if this object represents an array class;
<a name="line190"></a>     *          <code>false</code> otherwise.
<a name="line191"></a>     * @since   JDK1.1
<a name="line192"></a>     */
<a name="line193"></a>    public function isArray(){
<a name="line194"></a>        return $this->reflectionClass->getName() instanceof \ArrayObject;
<a name="line195"></a>    }
<a name="line196"></a>
<a name="line197"></a>    /**
<a name="line198"></a>     * Determines if the specified <code>Class</code> object represents a
<a name="line199"></a>     * primitive type.
<a name="line200"></a>     *
<a name="line201"></a>     * <p> There are nine predefined <code>Class</code> objects to represent
<a name="line202"></a>     * the eight primitive types and void.  These are created by the Java
<a name="line203"></a>     * Virtual Machine, and have the same names as the primitive types that
<a name="line204"></a>     * they represent, namely <code>boolean</code>, <code>byte</code>,
<a name="line205"></a>     * <code>char</code>, <code>short</code>, <code>int</code>,
<a name="line206"></a>     * <code>long</code>, <code>float</code>, and <code>double</code>.
<a name="line207"></a>     *
<a name="line208"></a>     * <p> These objects may only be accessed via the following public static
<a name="line209"></a>     * final variables, and are the only <code>Class</code> objects for which
<a name="line210"></a>     * this method returns <code>true</code>.
<a name="line211"></a>     *
<a name="line212"></a>     * @return true if and only if this class represents a primitive type
<a name="line213"></a>     *
<a name="line214"></a>     * @see     java.lang.Boolean#TYPE
<a name="line215"></a>     * @see     java.lang.Character#TYPE
<a name="line216"></a>     * @see     java.lang.Byte#TYPE
<a name="line217"></a>     * @see     java.lang.Short#TYPE
<a name="line218"></a>     * @see     java.lang.Integer#TYPE
<a name="line219"></a>     * @see     java.lang.Long#TYPE
<a name="line220"></a>     * @see     java.lang.Float#TYPE
<a name="line221"></a>     * @see     java.lang.Double#TYPE
<a name="line222"></a>     * @see     java.lang.Void#TYPE
<a name="line223"></a>     * @since JDK1.1
<a name="line224"></a>     */
<a name="line225"></a>    public function isPrimitive(){
<a name="line226"></a>        return false;
<a name="line227"></a>    }
<a name="line228"></a>
<a name="line229"></a>    /**
<a name="line230"></a>     * Returns <tt>true</tt> if this class is a synthetic class;
<a name="line231"></a>     * returns <tt>false</tt> otherwise.
<a name="line232"></a>     * @return <tt>true</tt> if and only if this class is a synthetic class as
<a name="line233"></a>     *         defined by the Java Language Specification.
<a name="line234"></a>     * @since 1.5
<a name="line235"></a>     */
<a name="line236"></a>    public function isSynthetic(){
<a name="line237"></a>        return $this->reflectionClass->isUserDefined();
<a name="line238"></a>    }
<a name="line239"></a>
<a name="line240"></a>    /**
<a name="line241"></a>     * Returns the  name of the entity (class, interface, array class,
<a name="line242"></a>     * primitive type, or void) represented by this <tt>Class</tt> object,
<a name="line243"></a>     * as a <tt>String</tt>.
<a name="line244"></a>     *
<a name="line245"></a>     * <p> If this class object represents a reference type that is not an
<a name="line246"></a>     * array type then the binary name of the class is returned, as specified
<a name="line247"></a>     * by the Java Language Specification, Second Edition.
<a name="line248"></a>     *
<a name="line249"></a>     * <p> If this class object represents a primitive type or void, then the
<a name="line250"></a>     * name returned is a <tt>String</tt> equal to the Java language
<a name="line251"></a>     * keyword corresponding to the primitive type or void.
<a name="line252"></a>     *
<a name="line253"></a>     * <p> If this class object represents a class of arrays, then the internal
<a name="line254"></a>     * form of the name consists of the name of the element type preceded by
<a name="line255"></a>     * one or more '<tt>[</tt>' characters representing the depth of the array
<a name="line256"></a>     * nesting.  The encoding of element type names is as follows:
<a name="line257"></a>     *
<a name="line258"></a>     * <blockquote><table summary="Element types and encodings">
<a name="line259"></a>     * <tr><th> Element Type <th> &nbsp;&nbsp;&nbsp; <th> Encoding
<a name="line260"></a>     * <tr><td> boolean      <td> &nbsp;&nbsp;&nbsp; <td align=center> Z
<a name="line261"></a>     * <tr><td> byte         <td> &nbsp;&nbsp;&nbsp; <td align=center> B
<a name="line262"></a>     * <tr><td> char         <td> &nbsp;&nbsp;&nbsp; <td align=center> C
<a name="line263"></a>     * <tr><td> class or interface
<a name="line264"></a>     *                       <td> &nbsp;&nbsp;&nbsp; <td align=center> L<i>classname</i>;
<a name="line265"></a>     * <tr><td> double       <td> &nbsp;&nbsp;&nbsp; <td align=center> D
<a name="line266"></a>     * <tr><td> float        <td> &nbsp;&nbsp;&nbsp; <td align=center> F
<a name="line267"></a>     * <tr><td> int          <td> &nbsp;&nbsp;&nbsp; <td align=center> I
<a name="line268"></a>     * <tr><td> long         <td> &nbsp;&nbsp;&nbsp; <td align=center> J
<a name="line269"></a>     * <tr><td> short        <td> &nbsp;&nbsp;&nbsp; <td align=center> S
<a name="line270"></a>     * </table></blockquote>
<a name="line271"></a>     *
<a name="line272"></a>     * <p> The class or interface name <i>classname</i> is the binary name of
<a name="line273"></a>     * the class specified above.
<a name="line274"></a>     *
<a name="line275"></a>     * <p> Examples:
<a name="line276"></a>     * <blockquote><pre>
<a name="line277"></a>     * String.class.getName()
<a name="line278"></a>     *     returns "java.lang.String"
<a name="line279"></a>     * byte.class.getName()
<a name="line280"></a>     *     returns "byte"
<a name="line281"></a>     * (new Object[3]).getClass().getName()
<a name="line282"></a>     *     returns "[Ljava.lang.Object;"
<a name="line283"></a>     * (new int[3][4][5][6][7][8][9]).getClass().getName()
<a name="line284"></a>     *     returns "[[[[[[[I"
<a name="line285"></a>     * </pre></blockquote>
<a name="line286"></a>     *
<a name="line287"></a>     * @return  the name of the class or interface
<a name="line288"></a>     *          represented by this object.
<a name="line289"></a>     */
<a name="line290"></a>    public function getName(){
<a name="line291"></a>        return $this->reflectionClass->getName();
<a name="line292"></a>    }
<a name="line293"></a>
<a name="line294"></a>    /**
<a name="line295"></a>     * Returns the class loader for the class.  Some implementations may use
<a name="line296"></a>     * null to represent the bootstrap class loader. This method will return
<a name="line297"></a>     * null in such implementations if this class was loaded by the bootstrap
<a name="line298"></a>     * class loader.
<a name="line299"></a>     *
<a name="line300"></a>     * <p> If a security manager is present, and the caller's class loader is
<a name="line301"></a>     * not null and the caller's class loader is not the same as or an ancestor of
<a name="line302"></a>     * the class loader for the class whose class loader is requested, then
<a name="line303"></a>     * this method calls the security manager's <code>checkPermission</code>
<a name="line304"></a>     * method with a <code>RuntimePermission("getClassLoader")</code>
<a name="line305"></a>     * permission to ensure it's ok to access the class loader for the class.
<a name="line306"></a>     *
<a name="line307"></a>     * <p>If this object
<a name="line308"></a>     * represents a primitive type or void, null is returned.
<a name="line309"></a>     *
<a name="line310"></a>     * @return blaze\lang\ClassLoader the class loader that loaded the class or interface
<a name="line311"></a>     *          represented by this object.
<a name="line312"></a>     * @throws SecurityException
<a name="line313"></a>     *    if a security manager exists and its
<a name="line314"></a>     *    <code>checkPermission</code> method denies
<a name="line315"></a>     *    access to the class loader for the class.
<a name="line316"></a>     * @see java.lang.ClassLoader
<a name="line317"></a>     * @see SecurityManager#checkPermission
<a name="line318"></a>     * @see java.lang.RuntimePermission
<a name="line319"></a>     */
<a name="line320"></a>    public function getClassLoader(){
<a name="line321"></a>        return ClassLoader::getInstance();
<a name="line322"></a>    }
<a name="line323"></a>
<a name="line324"></a>    /**
<a name="line325"></a>     * Returns the <code>Class</code> representing the superclass of the entity
<a name="line326"></a>     * (class, interface, primitive type or void) represented by this
<a name="line327"></a>     * <code>Class</code>.  If this <code>Class</code> represents either the
<a name="line328"></a>     * <code>Object</code> class, an interface, a primitive type, or void, then
<a name="line329"></a>     * null is returned.  If this object represents an array class then the
<a name="line330"></a>     * <code>Class</code> object representing the <code>Object</code> class is
<a name="line331"></a>     * returned.
<a name="line332"></a>     *
<a name="line333"></a>     * @return the superclass of the class represented by this object.
<a name="line334"></a>     */
<a name="line335"></a>    public function getSuperclass(){
<a name="line336"></a>        return new self($this->reflectionClass->getParentClass());
<a name="line337"></a>    }
<a name="line338"></a>
<a name="line339"></a>    /**
<a name="line340"></a>     * Gets the package for this class.  The class loader of this class is used
<a name="line341"></a>     * to find the package.  If the class was loaded by the bootstrap class
<a name="line342"></a>     * loader the set of packages loaded from CLASSPATH is searched to find the
<a name="line343"></a>     * package of the class. Null is returned if no package object was created
<a name="line344"></a>     * by the class loader of this class.
<a name="line345"></a>     *
<a name="line346"></a>     * <p> Packages have attributes for versions and specifications only if the
<a name="line347"></a>     * information was defined in the manifests that accompany the classes, and
<a name="line348"></a>     * if the class loader created the package instance with the attributes
<a name="line349"></a>     * from the manifest.
<a name="line350"></a>     *
<a name="line351"></a>     * @return the package of the class, or null if no package
<a name="line352"></a>     *         information is available from the archive or codebase.
<a name="line353"></a>     */
<a name="line354"></a>    public function getPackage() {
<a name="line355"></a>        return $this->reflectionClass->getNamespaceName();
<a name="line356"></a>    }
<a name="line357"></a>
<a name="line358"></a>    /**
<a name="line359"></a>     * Determines the interfaces implemented by the class or interface
<a name="line360"></a>     * represented by this object.
<a name="line361"></a>     *
<a name="line362"></a>     * <p> If this object represents a class, the return value is an array
<a name="line363"></a>     * containing objects representing all interfaces implemented by the
<a name="line364"></a>     * class. The order of the interface objects in the array corresponds to
<a name="line365"></a>     * the order of the interface names in the <code>implements</code> clause
<a name="line366"></a>     * of the declaration of the class represented by this object. For
<a name="line367"></a>     * example, given the declaration:
<a name="line368"></a>     * <blockquote><pre>
<a name="line369"></a>     * class Shimmer implements FloorWax, DessertTopping { ... }
<a name="line370"></a>     * </pre></blockquote>
<a name="line371"></a>     * suppose the value of <code>s</code> is an instance of
<a name="line372"></a>     * <code>Shimmer</code>; the value of the expression:
<a name="line373"></a>     * <blockquote><pre>
<a name="line374"></a>     * s.getClass().getInterfaces()[0]
<a name="line375"></a>     * </pre></blockquote>
<a name="line376"></a>     * is the <code>Class</code> object that represents interface
<a name="line377"></a>     * <code>FloorWax</code>; and the value of:
<a name="line378"></a>     * <blockquote><pre>
<a name="line379"></a>     * s.getClass().getInterfaces()[1]
<a name="line380"></a>     * </pre></blockquote>
<a name="line381"></a>     * is the <code>Class</code> object that represents interface
<a name="line382"></a>     * <code>DessertTopping</code>.
<a name="line383"></a>     *
<a name="line384"></a>     * <p> If this object represents an interface, the array contains objects
<a name="line385"></a>     * representing all interfaces extended by the interface. The order of the
<a name="line386"></a>     * interface objects in the array corresponds to the order of the interface
<a name="line387"></a>     * names in the <code>extends</code> clause of the declaration of the
<a name="line388"></a>     * interface represented by this object.
<a name="line389"></a>     *
<a name="line390"></a>     * <p> If this object represents a class or interface that implements no
<a name="line391"></a>     * interfaces, the method returns an array of length 0.
<a name="line392"></a>     *
<a name="line393"></a>     * <p> If this object represents a primitive type or void, the method
<a name="line394"></a>     * returns an array of length 0.
<a name="line395"></a>     *
<a name="line396"></a>     * @return an array of interfaces implemented by this class.
<a name="line397"></a>     */
<a name="line398"></a>    public function getInterfaces(){
<a name="line399"></a>        return $this->reflectionClass->getInterfaces();
<a name="line400"></a>    }
<a name="line401"></a>
<a name="line402"></a>    /**
<a name="line403"></a>     * Returns the Java language modifiers for this class or interface, encoded
<a name="line404"></a>     * in an integer. The modifiers consist of the Java Virtual Machine's
<a name="line405"></a>     * constants for <code>public</code>, <code>protected</code>,
<a name="line406"></a>     * <code>private</code>, <code>final</code>, <code>static</code>,
<a name="line407"></a>     * <code>abstract</code> and <code>interface</code>; they should be decoded
<a name="line408"></a>     * using the methods of class <code>Modifier</code>.
<a name="line409"></a>     *
<a name="line410"></a>     * <p> If the underlying class is an array class, then its
<a name="line411"></a>     * <code>public</code>, <code>private</code> and <code>protected</code>
<a name="line412"></a>     * modifiers are the same as those of its component type.  If this
<a name="line413"></a>     * <code>Class</code> represents a primitive type or void, its
<a name="line414"></a>     * <code>public</code> modifier is always <code>true</code>, and its
<a name="line415"></a>     * <code>protected</code> and <code>private</code> modifiers are always
<a name="line416"></a>     * <code>false</code>. If this object represents an array class, a
<a name="line417"></a>     * primitive type or void, then its <code>final</code> modifier is always
<a name="line418"></a>     * <code>true</code> and its interface modifier is always
<a name="line419"></a>     * <code>false</code>. The values of its other modifiers are not determined
<a name="line420"></a>     * by this specification.
<a name="line421"></a>     *
<a name="line422"></a>     * <p> The modifier encodings are defined in <em>The Java Virtual Machine
<a name="line423"></a>     * Specification</em>, table 4.1.
<a name="line424"></a>     *
<a name="line425"></a>     * @return the <code>int</code> representing the modifiers for this class
<a name="line426"></a>     * @see     java.lang.reflect.Modifier
<a name="line427"></a>     * @since JDK1.1
<a name="line428"></a>     */
<a name="line429"></a>    public function getModifiers(){
<a name="line430"></a>        return $this->reflectionClass->getModifiers();
<a name="line431"></a>    }
<a name="line432"></a>
<a name="line433"></a>    /**
<a name="line434"></a>     * Returns the simple name of the underlying class as given in the
<a name="line435"></a>     * source code. Returns an empty string if the underlying class is
<a name="line436"></a>     * anonymous.
<a name="line437"></a>     *
<a name="line438"></a>     * <p>The simple name of an array is the simple name of the
<a name="line439"></a>     * component type with "[]" appended.  In particular the simple
<a name="line440"></a>     * name of an array whose component type is anonymous is "[]".
<a name="line441"></a>     *
<a name="line442"></a>     * @return blaze\lang\String the simple name of the underlying class
<a name="line443"></a>     * @since 1.5
<a name="line444"></a>     */
<a name="line445"></a>    public function getSimpleName(){
<a name="line446"></a>        return new String($this->reflectionClass->getShortName());
<a name="line447"></a>    }
<a name="line448"></a>
<a name="line449"></a>    /**
<a name="line450"></a>     * Returns the canonical name of the underlying class as
<a name="line451"></a>     * defined by the Java Language Specification.  Returns null if
<a name="line452"></a>     * the underlying class does not have a canonical name (i.e., if
<a name="line453"></a>     * it is a local or anonymous class or an array whose component
<a name="line454"></a>     * type does not have a canonical name).
<a name="line455"></a>     * @return the canonical name of the underlying class if it exists, and
<a name="line456"></a>     * <tt>null</tt> otherwise.
<a name="line457"></a>     * @since 1.5
<a name="line458"></a>     */
<a name="line459"></a>    public function getFileName(){
<a name="line460"></a>        return new String($this->reflectionClass->getFileName());
<a name="line461"></a>    }
<a name="line462"></a>
<a name="line463"></a>    /**
<a name="line464"></a>     * Returns an array containing <code>Field</code> objects reflecting all
<a name="line465"></a>     * the accessible public fields of the class or interface represented by
<a name="line466"></a>     * this <code>Class</code> object.  The elements in the array returned are
<a name="line467"></a>     * not sorted and are not in any particular order.  This method returns an
<a name="line468"></a>     * array of length 0 if the class or interface has no accessible public
<a name="line469"></a>     * fields, or if it represents an array class, a primitive type, or void.
<a name="line470"></a>     *
<a name="line471"></a>     * <p> Specifically, if this <code>Class</code> object represents a class,
<a name="line472"></a>     * this method returns the public fields of this class and of all its
<a name="line473"></a>     * superclasses.  If this <code>Class</code> object represents an
<a name="line474"></a>     * interface, this method returns the fields of this interface and of all
<a name="line475"></a>     * its superinterfaces.
<a name="line476"></a>     *
<a name="line477"></a>     * <p> The implicit length field for array class is not reflected by this
<a name="line478"></a>     * method. User code should use the methods of class <code>Array</code> to
<a name="line479"></a>     * manipulate arrays.
<a name="line480"></a>     *
<a name="line481"></a>     * <p> See <em>The Java Language Specification</em>, sections 8.2 and 8.3.
<a name="line482"></a>     *
<a name="line483"></a>     * @return array[blaze\lang\reflect\Field] the array of <code>Field</code> objects representing the
<a name="line484"></a>     * public fields
<a name="line485"></a>     * @exception  SecurityException
<a name="line486"></a>     *             If a security manager, <i>s</i>, is present and any of the
<a name="line487"></a>     *             following conditions is met:
<a name="line488"></a>     *
<a name="line489"></a>     *             <ul>
<a name="line490"></a>     *
<a name="line491"></a>     *             <li> invocation of
<a name="line492"></a>     *             <tt>{@link SecurityManager#checkMemberAccess
<a name="line493"></a>     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
<a name="line494"></a>     *             access to the fields within this class
<a name="line495"></a>     *
<a name="line496"></a>     *             <li> the caller's class loader is not the same as or an
<a name="line497"></a>     *             ancestor of the class loader for the current class and
<a name="line498"></a>     *             invocation of <tt>{@link SecurityManager#checkPackageAccess
<a name="line499"></a>     *             s.checkPackageAccess()}</tt> denies access to the package
<a name="line500"></a>     *             of this class
<a name="line501"></a>     *
<a name="line502"></a>     *             </ul>
<a name="line503"></a>     *
<a name="line504"></a>     * @since JDK1.1
<a name="line505"></a>     */
<a name="line506"></a>    public function getFields(){
<a name="line507"></a>        $props = $this->reflectionClass->getProperties();
<a name="line508"></a>        $arr = array();
<a name="line509"></a>        foreach($props as $prop){
<a name="line510"></a>            $arr[] = new Field($prop);
<a name="line511"></a>        }
<a name="line512"></a>        return $arr;
<a name="line513"></a>    }
<a name="line514"></a>
<a name="line515"></a>    /**
<a name="line516"></a>     * Returns an array containing <code>Method</code> objects reflecting all
<a name="line517"></a>     * the public <em>member</em> methods of the class or interface represented
<a name="line518"></a>     * by this <code>Class</code> object, including those declared by the class
<a name="line519"></a>     * or interface and those inherited from superclasses and
<a name="line520"></a>     * superinterfaces.  Array classes return all the (public) member methods
<a name="line521"></a>     * inherited from the <code>Object</code> class.  The elements in the array
<a name="line522"></a>     * returned are not sorted and are not in any particular order.  This
<a name="line523"></a>     * method returns an array of length 0 if this <code>Class</code> object
<a name="line524"></a>     * represents a class or interface that has no public member methods, or if
<a name="line525"></a>     * this <code>Class</code> object represents a primitive type or void.
<a name="line526"></a>     *
<a name="line527"></a>     * <p> The class initialization method <code>&lt;clinit&gt;</code> is not
<a name="line528"></a>     * included in the returned array. If the class declares multiple public
<a name="line529"></a>     * member methods with the same parameter types, they are all included in
<a name="line530"></a>     * the returned array.
<a name="line531"></a>     *
<a name="line532"></a>     * <p> See <em>The Java Language Specification</em>, sections 8.2 and 8.4.
<a name="line533"></a>     *
<a name="line534"></a>     * @return blaze\util\ArrayObject the array of <code>Method</code> objects representing the
<a name="line535"></a>     * public methods of this class
<a name="line536"></a>     * @exception  SecurityException
<a name="line537"></a>     *             If a security manager, <i>s</i>, is present and any of the
<a name="line538"></a>     *             following conditions is met:
<a name="line539"></a>     *
<a name="line540"></a>     *             <ul>
<a name="line541"></a>     *
<a name="line542"></a>     *             <li> invocation of
<a name="line543"></a>     *             <tt>{@link SecurityManager#checkMemberAccess
<a name="line544"></a>     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
<a name="line545"></a>     *             access to the methods within this class
<a name="line546"></a>     *
<a name="line547"></a>     *             <li> the caller's class loader is not the same as or an
<a name="line548"></a>     *             ancestor of the class loader for the current class and
<a name="line549"></a>     *             invocation of <tt>{@link SecurityManager#checkPackageAccess
<a name="line550"></a>     *             s.checkPackageAccess()}</tt> denies access to the package
<a name="line551"></a>     *             of this class
<a name="line552"></a>     *
<a name="line553"></a>     *             </ul>
<a name="line554"></a>     *
<a name="line555"></a>     * @since JDK1.1
<a name="line556"></a>     */
<a name="line557"></a>    public function getMethods(){
<a name="line558"></a>        $methods = $this->reflectionClass->getMethods();
<a name="line559"></a>        $arr = array();
<a name="line560"></a>        foreach($methods as $prop){
<a name="line561"></a>            $arr[] = new Method($prop);
<a name="line562"></a>        }
<a name="line563"></a>        return $arr;
<a name="line564"></a>    }
<a name="line565"></a>
<a name="line566"></a>    public function getConstants(){
<a name="line567"></a>        $constants = $this->reflectionClass->getConstants();
<a name="line568"></a>        $arr = array();
<a name="line569"></a>        foreach($constants as $prop){
<a name="line570"></a>            $arr[] = new Method($prop);
<a name="line571"></a>        }
<a name="line572"></a>        return $arr;
<a name="line573"></a>    }
<a name="line574"></a>
<a name="line575"></a>
<a name="line576"></a>    /**
<a name="line577"></a>     * Returns a <code>Field</code> object that reflects the specified public
<a name="line578"></a>     * member field of the class or interface represented by this
<a name="line579"></a>     * <code>Class</code> object. The <code>name</code> parameter is a
<a name="line580"></a>     * <code>String</code> specifying the simple name of the desired field.
<a name="line581"></a>     *
<a name="line582"></a>     * <p> The field to be reflected is determined by the algorithm that
<a name="line583"></a>     * follows.  Let C be the class represented by this object:
<a name="line584"></a>     * <OL>
<a name="line585"></a>     * <LI> If C declares a public field with the name specified, that is the
<a name="line586"></a>     *      field to be reflected.</LI>
<a name="line587"></a>     * <LI> If no field was found in step 1 above, this algorithm is applied
<a name="line588"></a>     * 	    recursively to each direct superinterface of C. The direct
<a name="line589"></a>     * 	    superinterfaces are searched in the order they were declared.</LI>
<a name="line590"></a>     * <LI> If no field was found in steps 1 and 2 above, and C has a
<a name="line591"></a>     *      superclass S, then this algorithm is invoked recursively upon S.
<a name="line592"></a>     *      If C has no superclass, then a <code>NoSuchFieldException</code>
<a name="line593"></a>     *      is thrown.</LI>
<a name="line594"></a>     * </OL>
<a name="line595"></a>     *
<a name="line596"></a>     * <p> See <em>The Java Language Specification</em>, sections 8.2 and 8.3.
<a name="line597"></a>     *
<a name="line598"></a>     * @param name the field name
<a name="line599"></a>     * @return  the <code>Field</code> object of this class specified by
<a name="line600"></a>     * <code>name</code>
<a name="line601"></a>     * @exception NoSuchFieldException if a field with the specified name is
<a name="line602"></a>     *              not found.
<a name="line603"></a>     * @exception NullPointerException if <code>name</code> is <code>null</code>
<a name="line604"></a>     * @exception  SecurityException
<a name="line605"></a>     *             If a security manager, <i>s</i>, is present and any of the
<a name="line606"></a>     *             following conditions is met:
<a name="line607"></a>     *
<a name="line608"></a>     *             <ul>
<a name="line609"></a>     *
<a name="line610"></a>     *             <li> invocation of
<a name="line611"></a>     *             <tt>{@link SecurityManager#checkMemberAccess
<a name="line612"></a>     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
<a name="line613"></a>     *             access to the field
<a name="line614"></a>     *
<a name="line615"></a>     *             <li> the caller's class loader is not the same as or an
<a name="line616"></a>     *             ancestor of the class loader for the current class and
<a name="line617"></a>     *             invocation of <tt>{@link SecurityManager#checkPackageAccess
<a name="line618"></a>     *             s.checkPackageAccess()}</tt> denies access to the package
<a name="line619"></a>     *             of this class
<a name="line620"></a>     *
<a name="line621"></a>     *             </ul>
<a name="line622"></a>     *
<a name="line623"></a>     * @since JDK1.1
<a name="line624"></a>     */
<a name="line625"></a>    public function getField($name){
<a name="line626"></a>        try{
<a name="line627"></a>            return new Field($this->reflectionClass->getProperty(String::asNative($name)));
<a name="line628"></a>        }catch(\ReflectionException $e){
<a name="line629"></a>            throw new NoSuchFieldException($e->getMessage(), $e->getCode());
<a name="line630"></a>        }
<a name="line631"></a>    }
<a name="line632"></a>
<a name="line633"></a>    /**
<a name="line634"></a>     * Returns a <code>Method</code> object that reflects the specified public
<a name="line635"></a>     * member method of the class or interface represented by this
<a name="line636"></a>     * <code>Class</code> object. The <code>name</code> parameter is a
<a name="line637"></a>     * <code>String</code> specifying the simple name of the desired method. The
<a name="line638"></a>     * <code>parameterTypes</code> parameter is an array of <code>Class</code>
<a name="line639"></a>     * objects that identify the method's formal parameter types, in declared
<a name="line640"></a>     * order. If <code>parameterTypes</code> is <code>null</code>, it is
<a name="line641"></a>     * treated as if it were an empty array.
<a name="line642"></a>     *
<a name="line643"></a>     * <p> If the <code>name</code> is "{@code <init>};"or "{@code <clinit>}" a
<a name="line644"></a>     * <code>NoSuchMethodException</code> is raised. Otherwise, the method to
<a name="line645"></a>     * be reflected is determined by the algorithm that follows.  Let C be the
<a name="line646"></a>     * class represented by this object:
<a name="line647"></a>     * <OL>
<a name="line648"></a>     * <LI> C is searched for any <I>matching methods</I>. If no matching
<a name="line649"></a>     * 	    method is found, the algorithm of step 1 is invoked recursively on
<a name="line650"></a>     * 	    the superclass of C.</LI>
<a name="line651"></a>     * <LI> If no method was found in step 1 above, the superinterfaces of C
<a name="line652"></a>     *      are searched for a matching method. If any such method is found, it
<a name="line653"></a>     *      is reflected.</LI>
<a name="line654"></a>     * </OL>
<a name="line655"></a>     *
<a name="line656"></a>     * To find a matching method in a class C:&nbsp; If C declares exactly one
<a name="line657"></a>     * public method with the specified name and exactly the same formal
<a name="line658"></a>     * parameter types, that is the method reflected. If more than one such
<a name="line659"></a>     * method is found in C, and one of these methods has a return type that is
<a name="line660"></a>     * more specific than any of the others, that method is reflected;
<a name="line661"></a>     * otherwise one of the methods is chosen arbitrarily.
<a name="line662"></a>     *
<a name="line663"></a>     * <p>Note that there may be more than one matching method in a
<a name="line664"></a>     * class because while the Java language forbids a class to
<a name="line665"></a>     * declare multiple methods with the same signature but different
<a name="line666"></a>     * return types, the Java virtual machine does not.  This
<a name="line667"></a>     * increased flexibility in the virtual machine can be used to
<a name="line668"></a>     * implement various language features.  For example, covariant
<a name="line669"></a>     * returns can be implemented with {@linkplain
<a name="line670"></a>     * java.lang.reflect.Method#isBridge bridge methods}; the bridge
<a name="line671"></a>     * method and the method being overridden would have the same
<a name="line672"></a>     * signature but different return types.
<a name="line673"></a>     *
<a name="line674"></a>     * <p> See <em>The Java Language Specification</em>, sections 8.2 and 8.4.
<a name="line675"></a>     *
<a name="line676"></a>     * @param name the name of the method
<a name="line677"></a>     * @param parameterTypes the list of parameters
<a name="line678"></a>     * @return blaze\lang\reflect\Method the <code>Method</code> object that matches the specified
<a name="line679"></a>     * <code>name</code> and <code>parameterTypes</code>
<a name="line680"></a>     * @exception NoSuchMethodException if a matching method is not found
<a name="line681"></a>     *            or if the name is "&lt;init&gt;"or "&lt;clinit&gt;".
<a name="line682"></a>     * @exception NullPointerException if <code>name</code> is <code>null</code>
<a name="line683"></a>     * @exception  SecurityException
<a name="line684"></a>     *             If a security manager, <i>s</i>, is present and any of the
<a name="line685"></a>     *             following conditions is met:
<a name="line686"></a>     *
<a name="line687"></a>     *             <ul>
<a name="line688"></a>     *
<a name="line689"></a>     *             <li> invocation of
<a name="line690"></a>     *             <tt>{@link SecurityManager#checkMemberAccess
<a name="line691"></a>     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
<a name="line692"></a>     *             access to the method
<a name="line693"></a>     *
<a name="line694"></a>     *             <li> the caller's class loader is not the same as or an
<a name="line695"></a>     *             ancestor of the class loader for the current class and
<a name="line696"></a>     *             invocation of <tt>{@link SecurityManager#checkPackageAccess
<a name="line697"></a>     *             s.checkPackageAccess()}</tt> denies access to the package
<a name="line698"></a>     *             of this class
<a name="line699"></a>     *
<a name="line700"></a>     *             </ul>
<a name="line701"></a>     *
<a name="line702"></a>     * @since JDK1.1
<a name="line703"></a>     */
<a name="line704"></a>    public function getMethod($name) {
<a name="line705"></a>        try{
<a name="line706"></a>            return new Method($this->reflectionClass->getMethod(String::asNative($name)));
<a name="line707"></a>        }catch(\ReflectionException $e){
<a name="line708"></a>            throw new NoSuchMethodException($e->getMessage(), $e->getCode());
<a name="line709"></a>        }
<a name="line710"></a>    }
<a name="line711"></a>
<a name="line712"></a>    public function getConstant($name) {
<a name="line713"></a>        try{
<a name="line714"></a>            return new Method($this->reflectionClass->getConstant(String::asNative($name)));
<a name="line715"></a>        }catch(\ReflectionException $e){
<a name="line716"></a>            throw new NoSuchFieldException($e->getMessage(), $e->getCode());
<a name="line717"></a>        }
<a name="line718"></a>    }
<a name="line719"></a>
<a name="line720"></a>    /**
<a name="line721"></a>     * Returns a <code>Constructor</code> object that reflects the specified
<a name="line722"></a>     * public constructor of the class represented by this <code>Class</code>
<a name="line723"></a>     * object. The <code>parameterTypes</code> parameter is an array of
<a name="line724"></a>     * <code>Class</code> objects that identify the constructor's formal
<a name="line725"></a>     * parameter types, in declared order.
<a name="line726"></a>     *
<a name="line727"></a>     * If this <code>Class</code> object represents an inner class
<a name="line728"></a>     * declared in a non-static context, the formal parameter types
<a name="line729"></a>     * include the explicit enclosing instance as the first parameter.
<a name="line730"></a>     *
<a name="line731"></a>     * <p> The constructor to reflect is the public constructor of the class
<a name="line732"></a>     * represented by this <code>Class</code> object whose formal parameter
<a name="line733"></a>     * types match those specified by <code>parameterTypes</code>.
<a name="line734"></a>     *
<a name="line735"></a>     * @param parameterTypes the parameter array
<a name="line736"></a>     * @return blaze\lang\reflect\Method the <code>Constructor</code> object of the public constructor that
<a name="line737"></a>     * matches the specified <code>parameterTypes</code>
<a name="line738"></a>     * @exception NoSuchMethodException if a matching method is not found.
<a name="line739"></a>     * @exception  SecurityException
<a name="line740"></a>     *             If a security manager, <i>s</i>, is present and any of the
<a name="line741"></a>     *             following conditions is met:
<a name="line742"></a>     *
<a name="line743"></a>     *             <ul>
<a name="line744"></a>     *
<a name="line745"></a>     *             <li> invocation of
<a name="line746"></a>     *             <tt>{@link SecurityManager#checkMemberAccess
<a name="line747"></a>     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
<a name="line748"></a>     *             access to the constructor
<a name="line749"></a>     *
<a name="line750"></a>     *             <li> the caller's class loader is not the same as or an
<a name="line751"></a>     *             ancestor of the class loader for the current class and
<a name="line752"></a>     *             invocation of <tt>{@link SecurityManager#checkPackageAccess
<a name="line753"></a>     *             s.checkPackageAccess()}</tt> denies access to the package
<a name="line754"></a>     *             of this class
<a name="line755"></a>     *
<a name="line756"></a>     *             </ul>
<a name="line757"></a>     *
<a name="line758"></a>     * @since JDK1.1
<a name="line759"></a>     */
<a name="line760"></a>    public function getConstructor(){
<a name="line761"></a>        return new Method($this->reflectionClass->getConstructor());
<a name="line762"></a>    }
<a name="line763"></a>
<a name="line764"></a>    /**
<a name="line765"></a> * Finds a resource with a given name.  The rules for searching resources
<a name="line766"></a> * associated with a given class are implemented by the defining
<a name="line767"></a> * {@linkplain ClassLoader class loader} of the class.  This method
<a name="line768"></a> * delegates to this object's class loader.  If this object was loaded by
<a name="line769"></a> * the bootstrap class loader, the method delegates to {@link
<a name="line770"></a> * ClassLoader#getSystemResourceAsStream}.
<a name="line771"></a> *
<a name="line772"></a> * <p> Before delegation, an absolute resource name is constructed from the
<a name="line773"></a> * given resource name using this algorithm:
<a name="line774"></a> *
<a name="line775"></a> * <ul>
<a name="line776"></a> *
<a name="line777"></a> * <li> If the <tt>name</tt> begins with a <tt>'/'</tt>
<a name="line778"></a> * (<tt>'&#92;u002f'</tt>), then the absolute name of the resource is the
<a name="line779"></a> * portion of the <tt>name</tt> following the <tt>'/'</tt>.
<a name="line780"></a> *
<a name="line781"></a> * <li> Otherwise, the absolute name is of the following form:
<a name="line782"></a> *
<a name="line783"></a> * <blockquote><pre>
<a name="line784"></a> *   <tt>modified_package_name</tt>/<tt>name</tt>
<a name="line785"></a> * </pre></blockquote>
<a name="line786"></a> *
<a name="line787"></a> * <p> Where the <tt>modified_package_name</tt> is the package name of this
<a name="line788"></a> * object with <tt>'/'</tt> substituted for <tt>'.'</tt>
<a name="line789"></a> * (<tt>'&#92;u002e'</tt>).
<a name="line790"></a> *
<a name="line791"></a> * </ul>
<a name="line792"></a> *
<a name="line793"></a> * @param blaze\lang\String|string $name name of the desired resource
<a name="line794"></a> * @return      A {@link java.io.InputStream} object or <tt>null</tt> if
<a name="line795"></a> *              no resource with this name is found
<a name="line796"></a> * @throws  NullPointerException If <tt>name</tt> is <tt>null</tt>
<a name="line797"></a> * @since  JDK1.1
<a name="line798"></a> */
<a name="line799"></a>    public function getResourceAsStream($name){
<a name="line800"></a>        if($name instanceof String)
<a name="line801"></a>            return ClassLoader::getInstance()->getRessourceAsStream($name);
<a name="line802"></a>        else
<a name="line803"></a>            return ClassLoader::getInstance()->getRessourceAsStream(new String($name));
<a name="line804"></a>    }
<a name="line805"></a>
<a name="line806"></a>     /**
<a name="line807"></a>     * Finds a resource with a given name.  The rules for searching resources
<a name="line808"></a>     * associated with a given class are implemented by the defining
<a name="line809"></a>     * {@linkplain ClassLoader class loader} of the class.  This method
<a name="line810"></a>     * delegates to this object's class loader.  If this object was loaded by
<a name="line811"></a>     * the bootstrap class loader, the method delegates to {@link
<a name="line812"></a>     * ClassLoader#getSystemResource}.
<a name="line813"></a>     *
<a name="line814"></a>     * <p> Before delegation, an absolute resource name is constructed from the
<a name="line815"></a>     * given resource name using this algorithm:
<a name="line816"></a>     *
<a name="line817"></a>     * <ul>
<a name="line818"></a>     *
<a name="line819"></a>     * <li> If the <tt>name</tt> begins with a <tt>'/'</tt>
<a name="line820"></a>     * (<tt>'&#92;u002f'</tt>), then the absolute name of the resource is the
<a name="line821"></a>     * portion of the <tt>name</tt> following the <tt>'/'</tt>.
<a name="line822"></a>     *
<a name="line823"></a>     * <li> Otherwise, the absolute name is of the following form:
<a name="line824"></a>     *
<a name="line825"></a>     * <blockquote><pre>
<a name="line826"></a>     *   <tt>modified_package_name</tt>/<tt>name</tt>
<a name="line827"></a>     * </pre></blockquote>
<a name="line828"></a>     *
<a name="line829"></a>     * <p> Where the <tt>modified_package_name</tt> is the package name of this
<a name="line830"></a>     * object with <tt>'/'</tt> substituted for <tt>'.'</tt>
<a name="line831"></a>     * (<tt>'&#92;u002e'</tt>).
<a name="line832"></a>     *
<a name="line833"></a>     * </ul>
<a name="line834"></a>     *
<a name="line835"></a>     * @param blaze\lang\String|string $name name of the desired resource
<a name="line836"></a>     * @return      A  {@link java.net.URL} object or <tt>null</tt> if no
<a name="line837"></a>     *              resource with this name is found
<a name="line838"></a>     * @since  JDK1.1
<a name="line839"></a>     */
<a name="line840"></a>    public function getResource($name){
<a name="line841"></a>        if($name instanceof String)
<a name="line842"></a>            return ClassLoader::getInstance()->getResource($name);
<a name="line843"></a>        else
<a name="line844"></a>            return ClassLoader::getInstance()->getResource(new String($name));
<a name="line845"></a>    }
<a name="line846"></a>
<a name="line847"></a>    /**
<a name="line848"></a>     * Returns true if and only if this class was declared as an enum in the
<a name="line849"></a>     * source code.
<a name="line850"></a>     *
<a name="line851"></a>     * @return true if and only if this class was declared as an enum in the
<a name="line852"></a>     *     source code
<a name="line853"></a>     * @since 1.5
<a name="line854"></a>     */
<a name="line855"></a>    public function isEnum(){
<a name="line856"></a>        return $this->reflectionClass->isSubclassOf('blaze\lang\Enum');
<a name="line857"></a>    }
<a name="line858"></a>
<a name="line859"></a>    /**
<a name="line860"></a>     * Returns the elements of this enum class or null if this
<a name="line861"></a>     * Class object does not represent an enum type.
<a name="line862"></a>     *
<a name="line863"></a>     * @return an array containing the values comprising the enum class
<a name="line864"></a>     *     represented by this Class object in the order they're
<a name="line865"></a>     *     declared, or null if this Class object does not
<a name="line866"></a>     *     represent an enum type
<a name="line867"></a>     * @since 1.5
<a name="line868"></a>     */
<a name="line869"></a>    public function getEnumConstants(){
<a name="line870"></a>        if(!$this->isEnum())
<a name="line871"></a>            return null;
<a name="line872"></a>        return $this->reflectionClass->getConstants();
<a name="line873"></a>    }
<a name="line874"></a>
<a name="line875"></a>    /**
<a name="line876"></a>     * Casts an object to the class or interface represented
<a name="line877"></a>     * by this <tt>Class</tt> object.
<a name="line878"></a>     *
<a name="line879"></a>     * @param obj the object to be cast
<a name="line880"></a>     * @return blaze\lang\Object the object after casting, or null if obj is null
<a name="line881"></a>     *
<a name="line882"></a>     * @throws ClassCastException if the object is not
<a name="line883"></a>     * null and is not assignable to the type T.
<a name="line884"></a>     *
<a name="line885"></a>     * @since 1.5
<a name="line886"></a>     */
<a name="line887"></a>    public function cast(Reflectable $obj){
<a name="line888"></a>        if(!$this->reflectionClass->isInstance($obj))
<a name="line889"></a>            throw new ClassCastException();
<a name="line890"></a>        return $obj;
<a name="line891"></a>    }
<a name="line892"></a>
<a name="line893"></a>    /**
<a name="line894"></a>     *
<a name="line895"></a>     * @return array
<a name="line896"></a>     */
<a name="line897"></a>    public function getAnnotations(){
<a name="line898"></a>        $annotations = array();
<a name="line899"></a>
<a name="line900"></a>        if (preg_match_all('/@(?P<name>[A-Za-z_-]+)(?:[ \t]+(?P<value>.*?))?[ \t]*\r?$/m', $this->reflectionClass->getDocComment(), $matches)) {
<a name="line901"></a>            $numMatches = count($matches[0]);
<a name="line902"></a>
<a name="line903"></a>            for ($i = 0; $i < $numMatches; ++$i) {
<a name="line904"></a>                $annotations[$matches['name'][$i]][] = $matches['value'][$i];
<a name="line905"></a>            }
<a name="line906"></a>        }
<a name="line907"></a>
<a name="line908"></a>        return $annotations;
<a name="line909"></a>    }
<a name="line910"></a>
<a name="line911"></a>    /**
<a name="line912"></a>     *
<a name="line913"></a>     * @return boolean
<a name="line914"></a>     */
<a name="line915"></a>    public function hasAnnotations() {
<a name="line916"></a>        return count($this->getAnnotations()) != 0;
<a name="line917"></a>    }
<a name="line918"></a>}
<a name="line919"></a>?>
<a name="line920"></a></pre>
<div class="header">
<h1>Blaze Framework</h1>
<ul>
<li><a href="../overview-summary.html">Overview</a></li>
<li>Package</li><li>Class</li><li>Tree</li><li><a href="../overview-files.html">Files</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
</ul>
</div>

<div class="small_links">
<a href="../index.html" target="_top">Frames</a>
<a href="../source\blaze\lang\classwrapper.php.html" target="_top">No frames</a>
</div>
<hr>

<p id="footer">This document was generated by <a href="http://peej.github.com/phpdoctor/">PHPDoctor: The PHP Documentation Creator</a></p>

</body>

</html>